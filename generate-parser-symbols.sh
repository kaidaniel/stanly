[[ $1 ]] && nodes_json="$1" || nodes_json="build-default/tree-sitter-python/src/node-types.json"
[[ $2 ]] && lookup_symbols="$2" || lookup_symbols="build-default/src/lookup-symbols"

symbols=$(jq -r -c '.[] | select(.named) | select(.subtypes == null)' < $nodes_json)
name=$(jq -r '"sym_" + .type' <<< $symbols) 
optional_fields=$(jq -r -c '.fields // {} | map_values(select(.required == false)) | keys' <<< $symbols)
required_fields=$(jq -r -c '.fields // {} | map_values(select(.required)) | keys' <<< $symbols)
children=$(jq -r -c '.children.types // [] | [.[].type]' <<< $symbols)
all_fields=$(jq -r -c '.fields // {} | keys' <<< $symbols)
n_symbols=$(wc -l <<< $symbols)
norca_vars=$(paste -d "^" <(echo "$name") <(echo "$optional_fields") <(echo "$required_fields") <(echo "$children") <(echo "$all_fields") | awk '{ gsub("\[\]", ""); print  }' | tr -d "[]\"")
n=0


cat << PARSER_SYMBOLS_H > src/parser-symbols.h
#pragma once

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly {

enum class symbol { $(jq -r '.type' <<< $symbols | $lookup_symbols | awk '{ print "sym_" $0 ","; }') };
enum class field { $(jq -r ".[].fields | keys? | .[]" < $nodes_json | $lookup_symbols fields | awk '{ print "fld_" $0 ","; }') };


$( while IFS="^" read -r name optional_fields required_fields children all_fields; do
        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/parser-symbols.h" > /dev/tty
cat << EOF
struct $name {
    $([[ $children ]] && cat << CHILDREN_ENUM
    enum class children {
        $( while read f; do \
        [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
        echo "sym_$f = static_cast<int>(symbol::sym_$f)," || $( 
            for child in $(jq -r ".[] | select(.type == \"$f\").subtypes[].type" < $nodes_json); do
                [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                echo -n "sym_$child = static_cast<int>(symbol::sym_$f), "
            done);
        done <<< ${children//,/$'\n'}) };
CHILDREN_ENUM
)
    $( [[ $all_fields ]] && cat << FIELDS_ENUM
    enum class fields {
    $( while read f; do echo "fld_$f = static_cast<int>(field::fld_$f),"; done <<< ${all_fields//,/$'\n'})
    };
FIELDS_ENUM
)
};
EOF
    done <<< "$norca_vars")
}
PARSER_SYMBOLS_H

n=0
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/parser-symbols.h"


function lint {
    clang-format -i $1
    /home/kai/projects/install/bin/clang++ -x c++-header -std=c++20 -stdlib=libc++ -fexperimental-library -fsyntax-only $1 -Wall -Werror -Wno-unused-variable
}
lint src/parser-symbols.h

echo $(date +'%D %H:%M:%S') done linting
