#pragma once

#include <string_view>

#include "stanly-assert.h"
#include "tree_sitter/api.h"

// generated by stanly::generate_tree_sitter_symbols()

extern "C" {
TSLanguage*
tree_sitter_python(void);
}

namespace stanly {

TSSymbol
lookup_symbol(std::string_view name);
TSFieldId
lookup_field(std::string_view name);

struct fields {
  TSFieldId left = lookup_field("left");
  TSFieldId right = lookup_field("right");
  TSFieldId key = lookup_field("key");
  TSFieldId value = lookup_field("value");
  TSFieldId subscript = lookup_field("subscript");
  TSFieldId alias = lookup_field("alias");
  TSFieldId children = lookup_field("children");
  TSFieldId argument = lookup_field("argument");
} const fields{};

enum class simple_statement {
  import_statement = 108,
  future_import_statement = 111,
  import_from_statement = 112,
  print_statement = 116,
  assert_statement = 118,
  expression_statement = 119,
  return_statement = 122,
  delete_statement = 123,
  raise_statement = 124,
  pass_statement = 125,
  break_statement = 126,
  continue_statement = 127,
  global_statement = 146,
  nonlocal_statement = 147,
  exec_statement = 148,
};
enum class compound_statement {
  if_statement = 128,
  match_statement = 131,
  for_statement = 133,
  while_statement = 134,
  try_statement = 135,
  with_statement = 138,
  function_definition = 141,
  class_definition = 149,
  decorated_definition = 152,
};
enum class expression_statement {
  expression = 169,
  assignment = 178,
  augmented_assignment = 179,
  yield = 182,
};
enum class expression {
  identifier = 1,
  ellipsis = 83,
  integer = 92,
  s_float = 93,
  s_true = 95,
  s_false = 96,
  none = 97,
  named_expression = 120,
  as_pattern = 167,
  not_operator = 171,
  boolean_operator = 172,
  binary_operator = 173,
  unary_operator = 174,
  comparison_operator = 175,
  lambda = 176,
  attribute = 183,
  subscript = 184,
  call = 186,
  list = 190,
  set = 191,
  tuple = 192,
  dictionary = 193,
  list_comprehension = 195,
  dictionary_comprehension = 196,
  set_comprehension = 197,
  generator_expression = 198,
  parenthesized_expression = 200,
  conditional_expression = 204,
  concatenated_string = 205,
  string = 206,
  await = 211,
};
enum class dictionary {
  dictionary_splat = 145,
  pair = 194,
};
// clang-format off
inline void
check_symbols() {
  stanly_assert(static_cast<TSSymbol>(simple_statement::import_statement) == lookup_symbol("import_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::future_import_statement) == lookup_symbol("future_import_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::import_from_statement) == lookup_symbol("import_from_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::print_statement) == lookup_symbol("print_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::assert_statement) == lookup_symbol("assert_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::expression_statement) == lookup_symbol("expression_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::return_statement) == lookup_symbol("return_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::delete_statement) == lookup_symbol("delete_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::raise_statement) == lookup_symbol("raise_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::pass_statement) == lookup_symbol("pass_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::break_statement) == lookup_symbol("break_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::continue_statement) == lookup_symbol("continue_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::global_statement) == lookup_symbol("global_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::nonlocal_statement) == lookup_symbol("nonlocal_statement"));
  stanly_assert(static_cast<TSSymbol>(simple_statement::exec_statement) == lookup_symbol("exec_statement"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::if_statement) == lookup_symbol("if_statement"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::match_statement) == lookup_symbol("match_statement"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::for_statement) == lookup_symbol("for_statement"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::while_statement) == lookup_symbol("while_statement"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::try_statement) == lookup_symbol("try_statement"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::with_statement) == lookup_symbol("with_statement"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::function_definition) == lookup_symbol("function_definition"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::class_definition) == lookup_symbol("class_definition"));
  stanly_assert(static_cast<TSSymbol>(compound_statement::decorated_definition) == lookup_symbol("decorated_definition"));
  stanly_assert(static_cast<TSSymbol>(expression_statement::expression) == lookup_symbol("expression"));
  stanly_assert(static_cast<TSSymbol>(expression_statement::assignment) == lookup_symbol("assignment"));
  stanly_assert(static_cast<TSSymbol>(expression_statement::augmented_assignment) == lookup_symbol("augmented_assignment"));
  stanly_assert(static_cast<TSSymbol>(expression_statement::yield) == lookup_symbol("yield"));
  stanly_assert(static_cast<TSSymbol>(expression::identifier) == lookup_symbol("identifier"));
  stanly_assert(static_cast<TSSymbol>(expression::ellipsis) == lookup_symbol("ellipsis"));
  stanly_assert(static_cast<TSSymbol>(expression::integer) == lookup_symbol("integer"));
  stanly_assert(static_cast<TSSymbol>(expression::s_float) == lookup_symbol("float"));
  stanly_assert(static_cast<TSSymbol>(expression::s_true) == lookup_symbol("true"));
  stanly_assert(static_cast<TSSymbol>(expression::s_false) == lookup_symbol("false"));
  stanly_assert(static_cast<TSSymbol>(expression::none) == lookup_symbol("none"));
  stanly_assert(static_cast<TSSymbol>(expression::named_expression) == lookup_symbol("named_expression"));
  stanly_assert(static_cast<TSSymbol>(expression::as_pattern) == lookup_symbol("as_pattern"));
  stanly_assert(static_cast<TSSymbol>(expression::not_operator) == lookup_symbol("not_operator"));
  stanly_assert(static_cast<TSSymbol>(expression::boolean_operator) == lookup_symbol("boolean_operator"));
  stanly_assert(static_cast<TSSymbol>(expression::binary_operator) == lookup_symbol("binary_operator"));
  stanly_assert(static_cast<TSSymbol>(expression::unary_operator) == lookup_symbol("unary_operator"));
  stanly_assert(static_cast<TSSymbol>(expression::comparison_operator) == lookup_symbol("comparison_operator"));
  stanly_assert(static_cast<TSSymbol>(expression::lambda) == lookup_symbol("lambda"));
  stanly_assert(static_cast<TSSymbol>(expression::attribute) == lookup_symbol("attribute"));
  stanly_assert(static_cast<TSSymbol>(expression::subscript) == lookup_symbol("subscript"));
  stanly_assert(static_cast<TSSymbol>(expression::call) == lookup_symbol("call"));
  stanly_assert(static_cast<TSSymbol>(expression::list) == lookup_symbol("list"));
  stanly_assert(static_cast<TSSymbol>(expression::set) == lookup_symbol("set"));
  stanly_assert(static_cast<TSSymbol>(expression::tuple) == lookup_symbol("tuple"));
  stanly_assert(static_cast<TSSymbol>(expression::dictionary) == lookup_symbol("dictionary"));
  stanly_assert(static_cast<TSSymbol>(expression::list_comprehension) == lookup_symbol("list_comprehension"));
  stanly_assert(static_cast<TSSymbol>(expression::dictionary_comprehension) == lookup_symbol("dictionary_comprehension"));
  stanly_assert(static_cast<TSSymbol>(expression::set_comprehension) == lookup_symbol("set_comprehension"));
  stanly_assert(static_cast<TSSymbol>(expression::generator_expression) == lookup_symbol("generator_expression"));
  stanly_assert(static_cast<TSSymbol>(expression::parenthesized_expression) == lookup_symbol("parenthesized_expression"));
  stanly_assert(static_cast<TSSymbol>(expression::conditional_expression) == lookup_symbol("conditional_expression"));
  stanly_assert(static_cast<TSSymbol>(expression::concatenated_string) == lookup_symbol("concatenated_string"));
  stanly_assert(static_cast<TSSymbol>(expression::string) == lookup_symbol("string"));
  stanly_assert(static_cast<TSSymbol>(expression::await) == lookup_symbol("await"));
  stanly_assert(static_cast<TSSymbol>(dictionary::dictionary_splat) == lookup_symbol("dictionary_splat"));
  stanly_assert(static_cast<TSSymbol>(dictionary::pair) == lookup_symbol("pair"));
};
// clang-format on

std::string
generate_tree_sitter_symbols();
}  // namespace stanly
