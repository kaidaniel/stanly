#pragma once

#include <utility>

#include "program.hpp"

// generated by "./generate-parser.sh build-default/tree-sitter-python/src/node-types.json "

namespace stanly {

void parse_sym_aliased_import(program& p, std::string_view fld_alias, std::string_view fld_name);
void parse_sym_argument_list(
    program& p, std::optional<std::string_view> child_dictionary_splat,
    std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_keyword_argument,
    std::optional<std::string_view> child_list_splat,
    std::optional<std::string_view> child_parenthesized_expression);
void parse_sym_as_pattern(
    program& p, std::optional<std::string_view> child_expression, std::string_view fld_alias);
void parse_sym_assert_statement(program& p, std::optional<std::string_view> child_expression);
void parse_sym_assignment(
    program& p, std::optional<std::string_view> fld_right, std::optional<std::string_view> fld_type,
    std::string_view fld_left);
void parse_sym_attribute(program& p, std::string_view fld_attribute, std::string_view fld_object);
void parse_sym_augmented_assignment(
    program& p, std::string_view fld_left, std::string_view fld_operator,
    std::string_view fld_right);
void parse_sym_await(program& p, std::optional<std::string_view> child_expression);
void parse_sym_binary_operator(
    program& p, std::string_view fld_left, std::string_view fld_operator,
    std::string_view fld_right);
void parse_sym_block(
    program& p, std::optional<std::string_view> child__compound_statement,
    std::optional<std::string_view> child__simple_statement);
void parse_sym_boolean_operator(
    program& p, std::string_view fld_left, std::string_view fld_operator,
    std::string_view fld_right);
void parse_sym_break_statement(program& p);
void parse_sym_call(program& p, std::string_view fld_arguments, std::string_view fld_function);
void parse_sym_case_clause(
    program& p, std::optional<std::string_view> fld_guard, std::string_view fld_consequence,
    std::string_view fld_pattern);
void parse_sym_case_pattern(
    program& p, std::optional<std::string_view> child_attribute,
    std::optional<std::string_view> child_identifier,
    std::optional<std::string_view> child_subscript);
void parse_sym_chevron(program& p, std::optional<std::string_view> child_expression);
void parse_sym_class_definition(
    program& p, std::optional<std::string_view> fld_superclasses, std::string_view fld_body,
    std::string_view fld_name);
void parse_sym_comparison_operator(
    program& p, std::optional<std::string_view> child_primary_expression,
    std::string_view fld_operators);
void parse_sym_concatenated_string(program& p, std::optional<std::string_view> child_string);
void parse_sym_conditional_expression(program& p, std::optional<std::string_view> child_expression);
void parse_sym_continue_statement(program& p);
void parse_sym_decorated_definition(
    program& p, std::optional<std::string_view> child_decorator, std::string_view fld_definition);
void parse_sym_decorator(program& p, std::optional<std::string_view> child_primary_expression);
void parse_sym_default_parameter(program& p, std::string_view fld_name, std::string_view fld_value);
void parse_sym_delete_statement(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_expression_list);
void parse_sym_dictionary(
    program& p, std::optional<std::string_view> child_dictionary_splat,
    std::optional<std::string_view> child_pair);
void parse_sym_dictionary_comprehension(
    program& p, std::optional<std::string_view> child_for_in_clause,
    std::optional<std::string_view> child_if_clause, std::string_view fld_body);
void parse_sym_dictionary_splat(program& p, std::optional<std::string_view> child_expression);
void parse_sym_dictionary_splat_pattern(
    program& p, std::optional<std::string_view> child_attribute,
    std::optional<std::string_view> child_identifier,
    std::optional<std::string_view> child_subscript);
void parse_sym_dotted_name(program& p, std::optional<std::string_view> child_identifier);
void parse_sym_elif_clause(
    program& p, std::string_view fld_condition, std::string_view fld_consequence);
void parse_sym_else_clause(program& p, std::string_view fld_body);
void parse_sym_except_clause(
    program& p, std::optional<std::string_view> child_block,
    std::optional<std::string_view> child_expression);
void parse_sym_exec_statement(
    program& p, std::optional<std::string_view> child_expression, std::string_view fld_code);
void parse_sym_expression_list(program& p, std::optional<std::string_view> child_expression);
void parse_sym_expression_statement(
    program& p, std::optional<std::string_view> child_assignment,
    std::optional<std::string_view> child_augmented_assignment,
    std::optional<std::string_view> child_expression, std::optional<std::string_view> child_yield);
void parse_sym_finally_clause(program& p, std::optional<std::string_view> child_block);
void parse_sym_for_in_clause(program& p, std::string_view fld_left, std::string_view fld_right);
void parse_sym_for_statement(
    program& p, std::optional<std::string_view> fld_alternative, std::string_view fld_body,
    std::string_view fld_left, std::string_view fld_right);
void parse_sym_format_expression(program& p, std::optional<std::string_view> child_expression);
void parse_sym_format_specifier(
    program& p, std::optional<std::string_view> child_format_expression);
void parse_sym_function_definition(
    program& p, std::optional<std::string_view> fld_return_type, std::string_view fld_body,
    std::string_view fld_name, std::string_view fld_parameters);
void parse_sym_future_import_statement(program& p, std::string_view fld_name);
void parse_sym_generator_expression(
    program& p, std::optional<std::string_view> child_for_in_clause,
    std::optional<std::string_view> child_if_clause, std::string_view fld_body);
void parse_sym_global_statement(program& p, std::optional<std::string_view> child_identifier);
void parse_sym_if_clause(program& p, std::optional<std::string_view> child_expression);
void parse_sym_if_statement(
    program& p, std::optional<std::string_view> fld_alternative, std::string_view fld_condition,
    std::string_view fld_consequence);
void parse_sym_import_from_statement(
    program& p, std::optional<std::string_view> child_wildcard_import,
    std::optional<std::string_view> fld_name, std::string_view fld_module_name);
void parse_sym_import_prefix(program& p);
void parse_sym_import_statement(program& p, std::string_view fld_name);
void parse_sym_interpolation(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_format_specifier,
    std::optional<std::string_view> child_type_conversion);
void parse_sym_keyword_argument(program& p, std::string_view fld_name, std::string_view fld_value);
void parse_sym_keyword_separator(program& p);
void parse_sym_lambda(
    program& p, std::optional<std::string_view> fld_parameters, std::string_view fld_body);
void parse_sym_lambda_parameters(program& p, std::optional<std::string_view> child_parameter);
void parse_sym_list(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_list_splat,
    std::optional<std::string_view> child_parenthesized_list_splat,
    std::optional<std::string_view> child_yield);
void parse_sym_list_comprehension(
    program& p, std::optional<std::string_view> child_for_in_clause,
    std::optional<std::string_view> child_if_clause, std::string_view fld_body);
void parse_sym_list_pattern(program& p, std::optional<std::string_view> child_pattern);
void parse_sym_list_splat(program& p, std::optional<std::string_view> child_expression);
void parse_sym_list_splat_pattern(
    program& p, std::optional<std::string_view> child_attribute,
    std::optional<std::string_view> child_identifier,
    std::optional<std::string_view> child_subscript);
void parse_sym_match_statement(
    program& p, std::optional<std::string_view> fld_alternative, std::string_view fld_subject);
void parse_sym_module(
    program& p, std::optional<std::string_view> child__compound_statement,
    std::optional<std::string_view> child__simple_statement);
void parse_sym_named_expression(program& p, std::string_view fld_name, std::string_view fld_value);
void parse_sym_nonlocal_statement(program& p, std::optional<std::string_view> child_identifier);
void parse_sym_not_operator(program& p, std::string_view fld_argument);
void parse_sym_pair(program& p, std::string_view fld_key, std::string_view fld_value);
void parse_sym_parameters(program& p, std::optional<std::string_view> child_parameter);
void parse_sym_parenthesized_expression(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_list_splat,
    std::optional<std::string_view> child_parenthesized_expression,
    std::optional<std::string_view> child_yield);
void parse_sym_parenthesized_list_splat(
    program& p, std::optional<std::string_view> child_list_splat,
    std::optional<std::string_view> child_parenthesized_expression);
void parse_sym_pass_statement(program& p);
void parse_sym_pattern_list(program& p, std::optional<std::string_view> child_pattern);
void parse_sym_positional_separator(program& p);
void parse_sym_print_statement(
    program& p, std::optional<std::string_view> child_chevron,
    std::optional<std::string_view> fld_argument);
void parse_sym_raise_statement(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_expression_list,
    std::optional<std::string_view> fld_cause);
void parse_sym_relative_import(
    program& p, std::optional<std::string_view> child_dotted_name,
    std::optional<std::string_view> child_import_prefix);
void parse_sym_return_statement(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_expression_list);
void parse_sym_set(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_list_splat,
    std::optional<std::string_view> child_parenthesized_list_splat,
    std::optional<std::string_view> child_yield);
void parse_sym_set_comprehension(
    program& p, std::optional<std::string_view> child_for_in_clause,
    std::optional<std::string_view> child_if_clause, std::string_view fld_body);
void parse_sym_slice(program& p, std::optional<std::string_view> child_expression);
void parse_sym_string(
    program& p, std::optional<std::string_view> child_escape_sequence,
    std::optional<std::string_view> child_interpolation);
void parse_sym_subscript(program& p, std::string_view fld_subscript, std::string_view fld_value);
void parse_sym_try_statement(
    program& p, std::optional<std::string_view> child_else_clause,
    std::optional<std::string_view> child_except_clause,
    std::optional<std::string_view> child_finally_clause, std::string_view fld_body);
void parse_sym_tuple(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_list_splat,
    std::optional<std::string_view> child_parenthesized_list_splat,
    std::optional<std::string_view> child_yield);
void parse_sym_tuple_pattern(program& p, std::optional<std::string_view> child_pattern);
void parse_sym_type(program& p, std::optional<std::string_view> child_expression);
void parse_sym_typed_default_parameter(
    program& p, std::string_view fld_name, std::string_view fld_type, std::string_view fld_value);
void parse_sym_typed_parameter(
    program& p, std::optional<std::string_view> child_dictionary_splat_pattern,
    std::optional<std::string_view> child_identifier,
    std::optional<std::string_view> child_list_splat_pattern, std::string_view fld_type);
void parse_sym_unary_operator(
    program& p, std::string_view fld_argument, std::string_view fld_operator);
void parse_sym_while_statement(
    program& p, std::optional<std::string_view> fld_alternative, std::string_view fld_body,
    std::string_view fld_condition);
void parse_sym_wildcard_import(program& p);
void parse_sym_with_clause(program& p, std::optional<std::string_view> child_with_item);
void parse_sym_with_item(program& p, std::string_view fld_value);
void parse_sym_with_statement(
    program& p, std::optional<std::string_view> child_with_clause, std::string_view fld_body);
void parse_sym_yield(
    program& p, std::optional<std::string_view> child_expression,
    std::optional<std::string_view> child_expression_list);
void parse_sym_comment(program& p);
void parse_sym_ellipsis(program& p);
void parse_sym_escape_sequence(program& p);
void parse_sym_false(program& p);
void parse_sym_float(program& p);
void parse_sym_identifier(program& p);
void parse_sym_integer(program& p);
void parse_sym_none(program& p);
void parse_sym_true(program& p);
void parse_sym_type_conversion(program& p);
}  // namespace stanly
