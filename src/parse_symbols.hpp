#pragma once

#include <utility>

#include "handle.h"
#include "syntax.h"

// generated by "./generate_parser_skeleton.sh build-default/tree-sitter-python/src/node-types.json
// "

namespace stanly::parser {

struct cursor;
std::vector<syntax::basic_block>&
get_basic_blocks(cursor&);

void
parse_sym_aliased_import(cursor& c, handle fld_alias, handle fld_name);
void
parse_sym_argument_list(cursor& c, std::optional<handle> child_dictionary_splat,
                        std::optional<handle> child_expression,
                        std::optional<handle> child_keyword_argument,
                        std::optional<handle> child_list_splat,
                        std::optional<handle> child_parenthesized_expression);
void
parse_sym_as_pattern(cursor& c, std::optional<handle> child_expression, handle fld_alias);
void
parse_sym_assert_statement(cursor& c, std::optional<handle> child_expression);
void
parse_sym_assignment(cursor& c, std::optional<handle> fld_right, std::optional<handle> fld_type,
                     handle fld_left);
void
parse_sym_attribute(cursor& c, handle fld_attribute, handle fld_object);
void
parse_sym_augmented_assignment(cursor& c, handle fld_left, handle fld_operator, handle fld_right);
void
parse_sym_await(cursor& c, std::optional<handle> child_expression);
void
parse_sym_binary_operator(cursor& c, handle fld_left, handle fld_operator, handle fld_right);
void
parse_sym_block(cursor& c, std::optional<handle> child__compound_statement,
                std::optional<handle> child__simple_statement);
void
parse_sym_boolean_operator(cursor& c, handle fld_left, handle fld_operator, handle fld_right);
void
parse_sym_break_statement(cursor& c);
void
parse_sym_call(cursor& c, handle fld_arguments, handle fld_function);
void
parse_sym_case_clause(cursor& c, std::optional<handle> fld_guard, handle fld_consequence,
                      handle fld_pattern);
void
parse_sym_case_pattern(cursor& c, std::optional<handle> child_attribute,
                       std::optional<handle> child_identifier,
                       std::optional<handle> child_subscript);
void
parse_sym_chevron(cursor& c, std::optional<handle> child_expression);
void
parse_sym_class_definition(cursor& c, std::optional<handle> fld_superclasses, handle fld_body,
                           handle fld_name);
void
parse_sym_comparison_operator(cursor& c, std::optional<handle> child_primary_expression,
                              handle fld_operators);
void
parse_sym_concatenated_string(cursor& c, std::optional<handle> child_string);
void
parse_sym_conditional_expression(cursor& c, std::optional<handle> child_expression);
void
parse_sym_continue_statement(cursor& c);
void
parse_sym_decorated_definition(cursor& c, std::optional<handle> child_decorator,
                               handle fld_definition);
void
parse_sym_decorator(cursor& c, std::optional<handle> child_primary_expression);
void
parse_sym_default_parameter(cursor& c, handle fld_name, handle fld_value);
void
parse_sym_delete_statement(cursor& c, std::optional<handle> child_expression,
                           std::optional<handle> child_expression_list);
void
parse_sym_dictionary(cursor& c, std::optional<handle> child_dictionary_splat,
                     std::optional<handle> child_pair);
void
parse_sym_dictionary_comprehension(cursor& c, std::optional<handle> child_for_in_clause,
                                   std::optional<handle> child_if_clause, handle fld_body);
void
parse_sym_dictionary_splat(cursor& c, std::optional<handle> child_expression);
void
parse_sym_dictionary_splat_pattern(cursor& c, std::optional<handle> child_attribute,
                                   std::optional<handle> child_identifier,
                                   std::optional<handle> child_subscript);
void
parse_sym_dotted_name(cursor& c, std::optional<handle> child_identifier);
void
parse_sym_elif_clause(cursor& c, handle fld_condition, handle fld_consequence);
void
parse_sym_else_clause(cursor& c, handle fld_body);
void
parse_sym_except_clause(cursor& c, std::optional<handle> child_block,
                        std::optional<handle> child_expression);
void
parse_sym_exec_statement(cursor& c, std::optional<handle> child_expression, handle fld_code);
void
parse_sym_expression_list(cursor& c, std::optional<handle> child_expression);
void
parse_sym_expression_statement(cursor& c, std::optional<handle> child_assignment,
                               std::optional<handle> child_augmented_assignment,
                               std::optional<handle> child_expression,
                               std::optional<handle> child_yield);
void
parse_sym_finally_clause(cursor& c, std::optional<handle> child_block);
void
parse_sym_for_in_clause(cursor& c, handle fld_left, handle fld_right);
void
parse_sym_for_statement(cursor& c, std::optional<handle> fld_alternative, handle fld_body,
                        handle fld_left, handle fld_right);
void
parse_sym_format_expression(cursor& c, std::optional<handle> child_expression);
void
parse_sym_format_specifier(cursor& c, std::optional<handle> child_format_expression);
void
parse_sym_function_definition(cursor& c, std::optional<handle> fld_return_type, handle fld_body,
                              handle fld_name, handle fld_parameters);
void
parse_sym_future_import_statement(cursor& c, handle fld_name);
void
parse_sym_generator_expression(cursor& c, std::optional<handle> child_for_in_clause,
                               std::optional<handle> child_if_clause, handle fld_body);
void
parse_sym_global_statement(cursor& c, std::optional<handle> child_identifier);
void
parse_sym_if_clause(cursor& c, std::optional<handle> child_expression);
void
parse_sym_if_statement(cursor& c, std::optional<handle> fld_alternative, handle fld_condition,
                       handle fld_consequence);
void
parse_sym_import_from_statement(cursor& c, std::optional<handle> child_wildcard_import,
                                std::optional<handle> fld_name, handle fld_module_name);
void
parse_sym_import_prefix(cursor& c);
void
parse_sym_import_statement(cursor& c, handle fld_name);
void
parse_sym_interpolation(cursor& c, std::optional<handle> child_expression,
                        std::optional<handle> child_format_specifier,
                        std::optional<handle> child_type_conversion);
void
parse_sym_keyword_argument(cursor& c, handle fld_name, handle fld_value);
void
parse_sym_keyword_separator(cursor& c);
void
parse_sym_lambda(cursor& c, std::optional<handle> fld_parameters, handle fld_body);
void
parse_sym_lambda_parameters(cursor& c, std::optional<handle> child_parameter);
void
parse_sym_list(cursor& c, std::optional<handle> child_expression,
               std::optional<handle> child_list_splat,
               std::optional<handle> child_parenthesized_list_splat,
               std::optional<handle> child_yield);
void
parse_sym_list_comprehension(cursor& c, std::optional<handle> child_for_in_clause,
                             std::optional<handle> child_if_clause, handle fld_body);
void
parse_sym_list_pattern(cursor& c, std::optional<handle> child_pattern);
void
parse_sym_list_splat(cursor& c, std::optional<handle> child_expression);
void
parse_sym_list_splat_pattern(cursor& c, std::optional<handle> child_attribute,
                             std::optional<handle> child_identifier,
                             std::optional<handle> child_subscript);
void
parse_sym_match_statement(cursor& c, std::optional<handle> fld_alternative, handle fld_subject);
void
parse_sym_module(cursor& c, std::optional<handle> child__compound_statement,
                 std::optional<handle> child__simple_statement);
void
parse_sym_named_expression(cursor& c, handle fld_name, handle fld_value);
void
parse_sym_nonlocal_statement(cursor& c, std::optional<handle> child_identifier);
void
parse_sym_not_operator(cursor& c, handle fld_argument);
void
parse_sym_pair(cursor& c, handle fld_key, handle fld_value);
void
parse_sym_parameters(cursor& c, std::optional<handle> child_parameter);
void
parse_sym_parenthesized_expression(cursor& c, std::optional<handle> child_expression,
                                   std::optional<handle> child_list_splat,
                                   std::optional<handle> child_parenthesized_expression,
                                   std::optional<handle> child_yield);
void
parse_sym_parenthesized_list_splat(cursor& c, std::optional<handle> child_list_splat,
                                   std::optional<handle> child_parenthesized_expression);
void
parse_sym_pass_statement(cursor& c);
void
parse_sym_pattern_list(cursor& c, std::optional<handle> child_pattern);
void
parse_sym_positional_separator(cursor& c);
void
parse_sym_print_statement(cursor& c, std::optional<handle> child_chevron,
                          std::optional<handle> fld_argument);
void
parse_sym_raise_statement(cursor& c, std::optional<handle> child_expression,
                          std::optional<handle> child_expression_list,
                          std::optional<handle> fld_cause);
void
parse_sym_relative_import(cursor& c, std::optional<handle> child_dotted_name,
                          std::optional<handle> child_import_prefix);
void
parse_sym_return_statement(cursor& c, std::optional<handle> child_expression,
                           std::optional<handle> child_expression_list);
void
parse_sym_set(cursor& c, std::optional<handle> child_expression,
              std::optional<handle> child_list_splat,
              std::optional<handle> child_parenthesized_list_splat,
              std::optional<handle> child_yield);
void
parse_sym_set_comprehension(cursor& c, std::optional<handle> child_for_in_clause,
                            std::optional<handle> child_if_clause, handle fld_body);
void
parse_sym_slice(cursor& c, std::optional<handle> child_expression);
void
parse_sym_string(cursor& c, std::optional<handle> child_escape_sequence,
                 std::optional<handle> child_interpolation);
void
parse_sym_subscript(cursor& c, handle fld_subscript, handle fld_value);
void
parse_sym_try_statement(cursor& c, std::optional<handle> child_else_clause,
                        std::optional<handle> child_except_clause,
                        std::optional<handle> child_finally_clause, handle fld_body);
void
parse_sym_tuple(cursor& c, std::optional<handle> child_expression,
                std::optional<handle> child_list_splat,
                std::optional<handle> child_parenthesized_list_splat,
                std::optional<handle> child_yield);
void
parse_sym_tuple_pattern(cursor& c, std::optional<handle> child_pattern);
void
parse_sym_type(cursor& c, std::optional<handle> child_expression);
void
parse_sym_typed_default_parameter(cursor& c, handle fld_name, handle fld_type, handle fld_value);
void
parse_sym_typed_parameter(cursor& c, std::optional<handle> child_dictionary_splat_pattern,
                          std::optional<handle> child_identifier,
                          std::optional<handle> child_list_splat_pattern, handle fld_type);
void
parse_sym_unary_operator(cursor& c, handle fld_argument, handle fld_operator);
void
parse_sym_while_statement(cursor& c, std::optional<handle> fld_alternative, handle fld_body,
                          handle fld_condition);
void
parse_sym_wildcard_import(cursor& c);
void
parse_sym_with_clause(cursor& c, std::optional<handle> child_with_item);
void
parse_sym_with_item(cursor& c, handle fld_value);
void
parse_sym_with_statement(cursor& c, std::optional<handle> child_with_clause, handle fld_body);
void
parse_sym_yield(cursor& c, std::optional<handle> child_expression,
                std::optional<handle> child_expression_list);
void
parse_sym_comment(cursor& c);
void
parse_sym_ellipsis(cursor& c);
void
parse_sym_escape_sequence(cursor& c);
void
parse_sym_false(cursor& c);
void
parse_sym_float(cursor& c);
void
parse_sym_identifier(cursor& c);
void
parse_sym_integer(cursor& c);
void
parse_sym_none(cursor& c);
void
parse_sym_true(cursor& c);
void
parse_sym_type_conversion(cursor& c);
}  // namespace stanly::parser
