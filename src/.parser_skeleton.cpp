#include <string_view>
#include <utility>

#include "parser.hpp"

// generated by "./generate_parser_skeleton.sh build-default/tree-sitter-python/src/node-types.json
// "

namespace stanly::parser {

void
parse_sym__compound_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    subtypes:
      class_definition
      decorated_definition
      for_statement
      function_definition
      if_statement
      match_statement
      try_statement
      while_statement
      with_statement
  */
}
void
parse_sym__simple_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    subtypes:
      assert_statement
      break_statement
      continue_statement
      delete_statement
      exec_statement
      expression_statement
      future_import_statement
      global_statement
      import_from_statement
      import_statement
      nonlocal_statement
      pass_statement
      print_statement
      raise_statement
      return_statement
  */
}
void
parse_sym_expression(parser& p, std::optional<std::string_view> children

) {
  /*
    subtypes:
      as_pattern
      await
      boolean_operator
      comparison_operator
      conditional_expression
      lambda
      named_expression
      not_operator
      primary_expression
  */
}
void
parse_sym_parameter(parser& p, std::optional<std::string_view> children

) {
  /*
    subtypes:
      default_parameter
      dictionary_splat_pattern
      identifier
      keyword_separator
      list_splat_pattern
      positional_separator
      tuple_pattern
      typed_default_parameter
      typed_parameter
  */
}
void
parse_sym_pattern(parser& p, std::optional<std::string_view> children

) {
  /*
    subtypes:
      attribute
      identifier
      list_pattern
      list_splat_pattern
      subscript
      tuple_pattern
  */
}
void
parse_sym_primary_expression(parser& p, std::optional<std::string_view> children

) {
  /*
    subtypes:
      attribute
      binary_operator
      call
      concatenated_string
      dictionary
      dictionary_comprehension
      ellipsis
      false
      float
      generator_expression
      identifier
      integer
      list
      list_comprehension
      none
      parenthesized_expression
      set
      set_comprehension
      string
      subscript
      true
      tuple
      unary_operator
  */
}
void
parse_sym_aliased_import(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_alias, std::optional<std::string_view> sym_name) {
  /*
    fields:
      alias:
        identifier
      name:
        dotted_name
  */
}
void
parse_sym_argument_list(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        dictionary_splat
        expression
        keyword_argument
        list_splat
        parenthesized_expression
  */
}
void
parse_sym_as_pattern(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_alias) {
  /*
    fields:
      alias:
        as_pattern_target
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_assert_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        expression
  */
}
void
parse_sym_assignment(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_left, std::optional<std::string_view> sym_right,
    std::optional<std::string_view> sym_type) {
  /*
    fields:
      left:
        pattern
        pattern_list
      right:
        assignment
        augmented_assignment
        expression
        expression_list
        yield
      type:
        type
  */
}
void
parse_sym_attribute(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_attribute, std::optional<std::string_view> sym_object) {
  /*
    fields:
      attribute:
        identifier
      object:
        primary_expression
  */
}
void
parse_sym_augmented_assignment(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_left, std::optional<std::string_view> sym_operator,
    std::optional<std::string_view> sym_right) {
  /*
    fields:
      left:
        pattern
        pattern_list
      operator:
        %=
        &=
        **=
        *=
        +=
        -=
        //=
        /=
        <<=
        >>=
        @=
        ^=
        |=
      right:
        assignment
        augmented_assignment
        expression
        expression_list
        yield
  */
}
void
parse_sym_await(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_binary_operator(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_left, std::optional<std::string_view> sym_operator,
    std::optional<std::string_view> sym_right) {
  /*
    fields:
      left:
        primary_expression
      operator:
        %
        &
        *
        **
        +
        -
        /
        //
        <<
        >>
        @
        ^
        |
      right:
        primary_expression
  */
}
void
parse_sym_block(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        _compound_statement
        _simple_statement
  */
}
void
parse_sym_boolean_operator(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_left, std::optional<std::string_view> sym_operator,
    std::optional<std::string_view> sym_right) {
  /*
    fields:
      left:
        expression
      operator:
        and
        or
      right:
        expression
  */
}
void
parse_sym_break_statement(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_call(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_arguments, std::optional<std::string_view> sym_function) {
  /*
    fields:
      arguments:
        argument_list
        generator_expression
      function:
        primary_expression
  */
}
void
parse_sym_case_clause(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_consequence, std::optional<std::string_view> sym_guard,
    std::optional<std::string_view> sym_pattern) {
  /*
    fields:
      consequence:
        block
      guard:
        if_clause
      pattern:
        case_pattern
  */
}
void
parse_sym_case_pattern(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        attribute
        identifier
        subscript
  */
}
void
parse_sym_chevron(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_class_definition(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_body, std::optional<std::string_view> sym_name,
    std::optional<std::string_view> sym_superclasses) {
  /*
    fields:
      body:
        block
      name:
        identifier
      superclasses:
        argument_list
  */
}
void
parse_sym_comparison_operator(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_operators) {
  /*
    fields:
      operators:
        !=
        <
        <=
        <>
        ==
        >
        >=
        in
        is
        not
    children:
      multiple: true
      required: true
      types:
        primary_expression
  */
}
void
parse_sym_concatenated_string(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        string
  */
}
void
parse_sym_conditional_expression(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        expression
  */
}
void
parse_sym_continue_statement(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_decorated_definition(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_definition) {
  /*
    fields:
      definition:
        class_definition
        function_definition
    children:
      multiple: true
      required: true
      types:
        decorator
  */
}
void
parse_sym_decorator(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        primary_expression
  */
}
void
parse_sym_default_parameter(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_name, std::optional<std::string_view> sym_value) {
  /*
    fields:
      name:
        identifier
      value:
        expression
  */
}
void
parse_sym_delete_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
        expression_list
  */
}
void
parse_sym_dictionary(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        dictionary_splat
        pair
  */
}
void
parse_sym_dictionary_comprehension(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_body) {
  /*
    fields:
      body:
        pair
    children:
      multiple: true
      required: true
      types:
        for_in_clause
        if_clause
  */
}
void
parse_sym_dictionary_splat(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_dictionary_splat_pattern(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        attribute
        identifier
        subscript
  */
}
void
parse_sym_dotted_name(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        identifier
  */
}
void
parse_sym_elif_clause(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_condition,
    std::optional<std::string_view> sym_consequence) {
  /*
    fields:
      condition:
        expression
      consequence:
        block
  */
}
void
parse_sym_else_clause(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_body) {
  /*
    fields:
      body:
        block
  */
}
void
parse_sym_except_clause(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        block
        expression
  */
}
void
parse_sym_exec_statement(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_code) {
  /*
    fields:
      code:
        string
    children:
      multiple: true
      required: false
      types:
        expression
  */
}
void
parse_sym_expression_list(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        expression
  */
}
void
parse_sym_expression_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        assignment
        augmented_assignment
        expression
        yield
  */
}
void
parse_sym_finally_clause(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        block
  */
}
void
parse_sym_for_in_clause(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_left, std::optional<std::string_view> sym_right) {
  /*
    fields:
      left:
        pattern
        pattern_list
      right:
        expression
  */
}
void
parse_sym_for_statement(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_alternative, std::optional<std::string_view> sym_body,
    std::optional<std::string_view> sym_left, std::optional<std::string_view> sym_right) {
  /*
    fields:
      alternative:
        else_clause
      body:
        block
      left:
        pattern
        pattern_list
      right:
        expression
        expression_list
  */
}
void
parse_sym_format_expression(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_format_specifier(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        format_expression
  */
}
void
parse_sym_function_definition(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_body, std::optional<std::string_view> sym_name,
    std::optional<std::string_view> sym_parameters,
    std::optional<std::string_view> sym_return_type) {
  /*
    fields:
      body:
        block
      name:
        identifier
      parameters:
        parameters
      return_type:
        type
  */
}
void
parse_sym_future_import_statement(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_name) {
  /*
    fields:
      name:
        aliased_import
        dotted_name
  */
}
void
parse_sym_generator_expression(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_body) {
  /*
    fields:
      body:
        expression
    children:
      multiple: true
      required: true
      types:
        for_in_clause
        if_clause
  */
}
void
parse_sym_global_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        identifier
  */
}
void
parse_sym_if_clause(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_if_statement(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_alternative, std::optional<std::string_view> sym_condition,
    std::optional<std::string_view> sym_consequence) {
  /*
    fields:
      alternative:
        elif_clause
        else_clause
      condition:
        expression
      consequence:
        block
  */
}
void
parse_sym_import_from_statement(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_module_name, std::optional<std::string_view> sym_name) {
  /*
    fields:
      module_name:
        dotted_name
        relative_import
      name:
        aliased_import
        dotted_name
    children:
      multiple: false
      required: false
      types:
        wildcard_import
  */
}
void
parse_sym_import_prefix(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_import_statement(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_name) {
  /*
    fields:
      name:
        aliased_import
        dotted_name
  */
}
void
parse_sym_interpolation(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        expression
        format_specifier
        type_conversion
  */
}
void
parse_sym_keyword_argument(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_name, std::optional<std::string_view> sym_value) {
  /*
    fields:
      name:
        identifier
      value:
        expression
  */
}
void
parse_sym_keyword_separator(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_lambda(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_body, std::optional<std::string_view> sym_parameters) {
  /*
    fields:
      body:
        expression
      parameters:
        lambda_parameters
  */
}
void
parse_sym_lambda_parameters(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        parameter
  */
}
void
parse_sym_list(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        expression
        list_splat
        parenthesized_list_splat
        yield
  */
}
void
parse_sym_list_comprehension(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_body) {
  /*
    fields:
      body:
        expression
    children:
      multiple: true
      required: true
      types:
        for_in_clause
        if_clause
  */
}
void
parse_sym_list_pattern(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        pattern
  */
}
void
parse_sym_list_splat(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_list_splat_pattern(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        attribute
        identifier
        subscript
  */
}
void
parse_sym_match_statement(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_alternative, std::optional<std::string_view> sym_subject) {
  /*
    fields:
      alternative:
        case_clause
      subject:
        expression
  */
}
void
parse_sym_module(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        _compound_statement
        _simple_statement
  */
}
void
parse_sym_named_expression(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_name, std::optional<std::string_view> sym_value) {
  /*
    fields:
      name:
        identifier
      value:
        expression
  */
}
void
parse_sym_nonlocal_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        identifier
  */
}
void
parse_sym_not_operator(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_argument) {
  /*
    fields:
      argument:
        expression
  */
}
void
parse_sym_pair(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_key, std::optional<std::string_view> sym_value) {
  /*
    fields:
      key:
        expression
      value:
        expression
  */
}
void
parse_sym_parameters(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        parameter
  */
}
void
parse_sym_parenthesized_expression(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
        list_splat
        parenthesized_expression
        yield
  */
}
void
parse_sym_parenthesized_list_splat(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        list_splat
        parenthesized_expression
  */
}
void
parse_sym_pass_statement(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_pattern_list(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        pattern
  */
}
void
parse_sym_positional_separator(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_print_statement(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_argument) {
  /*
    fields:
      argument:
        expression
    children:
      multiple: false
      required: false
      types:
        chevron
  */
}
void
parse_sym_raise_statement(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_cause) {
  /*
    fields:
      cause:
        expression
    children:
      multiple: false
      required: false
      types:
        expression
        expression_list
  */
}
void
parse_sym_relative_import(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        dotted_name
        import_prefix
  */
}
void
parse_sym_return_statement(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: false
      types:
        expression
        expression_list
  */
}
void
parse_sym_set(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        expression
        list_splat
        parenthesized_list_splat
        yield
  */
}
void
parse_sym_set_comprehension(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_body) {
  /*
    fields:
      body:
        expression
    children:
      multiple: true
      required: true
      types:
        for_in_clause
        if_clause
  */
}
void
parse_sym_slice(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        expression
  */
}
void
parse_sym_string(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        escape_sequence
        interpolation
  */
}
void
parse_sym_subscript(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_subscript, std::optional<std::string_view> sym_value) {
  /*
    fields:
      subscript:
        expression
        slice
      value:
        primary_expression
  */
}
void
parse_sym_try_statement(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_body) {
  /*
    fields:
      body:
        block
    children:
      multiple: true
      required: true
      types:
        else_clause
        except_clause
        finally_clause
  */
}
void
parse_sym_tuple(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        expression
        list_splat
        parenthesized_list_splat
        yield
  */
}
void
parse_sym_tuple_pattern(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: false
      types:
        pattern
  */
}
void
parse_sym_type(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: true
      types:
        expression
  */
}
void
parse_sym_typed_default_parameter(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_name, std::optional<std::string_view> sym_type,
    std::optional<std::string_view> sym_value) {
  /*
    fields:
      name:
        identifier
      type:
        type
      value:
        expression
  */
}
void
parse_sym_typed_parameter(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_type) {
  /*
    fields:
      type:
        type
    children:
      multiple: false
      required: true
      types:
        dictionary_splat_pattern
        identifier
        list_splat_pattern
  */
}
void
parse_sym_unary_operator(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_argument, std::optional<std::string_view> sym_operator) {
  /*
    fields:
      argument:
        primary_expression
      operator:
        +
        -
        ~
  */
}
void
parse_sym_while_statement(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_alternative, std::optional<std::string_view> sym_body,
    std::optional<std::string_view> sym_condition) {
  /*
    fields:
      alternative:
        else_clause
      body:
        block
      condition:
        expression
  */
}
void
parse_sym_wildcard_import(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_with_clause(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: true
      required: true
      types:
        with_item
  */
}
void
parse_sym_with_item(parser& p, std::optional<std::string_view> children,
    std::optional<std::string_view> sym_value) {
  /*
    fields:
      value:
        expression
  */
}
void
parse_sym_with_statement(
    parser& p, std::optional<std::string_view> children, std::optional<std::string_view> sym_body) {
  /*
    fields:
      body:
        block
    children:
      multiple: false
      required: true
      types:
        with_clause
  */
}
void
parse_sym_yield(parser& p, std::optional<std::string_view> children

) {
  /*
    children:
      multiple: false
      required: false
      types:
        expression
        expression_list
  */
}
void
parse_sym_comment(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_ellipsis(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_escape_sequence(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_false(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_float(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_identifier(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_integer(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_none(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_true(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
void
parse_sym_type_conversion(parser& p, std::optional<std::string_view> children

) {
  /*

  */
}
}  // namespace stanly::parser
