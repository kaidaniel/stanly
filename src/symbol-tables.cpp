#include "symbol-tables.h"

#include <__ranges/concepts.h>
#include <__ranges/join_view.h>

#include <cstdlib>
#include <iostream>
#include <map>
#include <numeric>
#include <ranges>
#include <set>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>

namespace stanly {

namespace rg = std::ranges;
namespace vw = rg::views;
std::string
process(std::string_view command) {
  std::array<char, 1024> buffer{};
  std::string out;
  FILE* pipe = popen(command.data(), "r");
  if (pipe == nullptr) {
    std::cerr << "Failed to create pipe.\n";
    std::exit(1);
  }
  while (size_t bytes = std::fread(buffer.data(), 1, buffer.size(), pipe)) {
    out.append(buffer.data(), bytes);
  }
  pclose(pipe);
  return out;
}

std::vector<std::string>
split(const std::string& str, const char sep = '\n') {
  std::vector<std::string> out;
  std::stringstream ss{str};
  for (std::string el; std::getline(ss, el, sep);) { out.push_back(el); }
  return out;
}

template <class Range>
std::vector<rg::range_value_t<Range>>
to_vec(Range&& range) {
  std::vector<rg::range_value_t<Range>> out{};
  for (const auto& e : range) { out.push_back(e); }
  return out;
}

auto
reduce(auto&& range, auto&& f) {
  return std::accumulate(rg::begin(range), rg::end(range), rg::range_value_t<decltype(range)>{}, f);
}

std::vector<std::string>
all_tree_sitter_dependent_nodes(std::string_view node_types_json, std::string_view tp) {
  static constexpr const char* fmt = "< {} jq -r '.[] | select(.type==\"{}\") | {}' 2>/dev/null";
  auto call_jq = [&](auto q) { return split(process(std::format(fmt, node_types_json, tp, q))); };
  auto queries = std::vector{".subtypes[].type", ".children.types[].type"};
  return to_vec(queries | vw::transform(call_jq) | vw::join);
}

std::tuple<std::string, std::string>
make_enum(const std::vector<std::string>& items, std::string_view name) {
  std::map<TSSymbol, std::tuple<std::string, std::string>> m;
  std::string name_ = std::string{name[0] == '_' ? name.substr(1, name.size() - 1) : name};
  std::string enum_str = std::format("enum class {} {}\n", name_, "{");
  std::string check_str;
  static std::set<std::string> cpp_key_words{"true", "false", "int", "float"};
  static constexpr const char* check_fmt =
      "  stanly_assert(static_cast<TSSymbol>({}::{}) == lookup_symbol(\"{}\"));\n";
  for (const auto& s : items) {
    auto sym = lookup_symbol(s);
    stanly_assert(sym != 0U, std::format("symbol '{}' not found.", s));
    m[sym] = std::tuple{cpp_key_words.contains(s) ? std::format("s_{}", s) : s, s};
  }
  for (const auto& [sym, nm] : m) {
    if (std::get<0>(nm) == "primary_expression") { continue; }
    enum_str += std::format("  {} = {},\n", std::get<0>(nm), sym);
    check_str += std::format(check_fmt, name_, std::get<0>(nm), std::get<1>(nm));
  }
  return {enum_str + "};\n", check_str};
}

std::tuple<std::string, std::string>
make_enum(std::string_view node_types_json, std::string_view name) {
  auto items = all_tree_sitter_dependent_nodes(node_types_json, name);
  if (name == "expression") {
    for (auto&& s : all_tree_sitter_dependent_nodes(node_types_json, "primary_expression")) {
      items.push_back(std::move(s));
    }
  }
  return make_enum(items, name);
};

std::string
generate_tree_sitter_symbols(std::string_view node_types_json) {
  const std::string preamble = R"(#pragma once

#include <string_view>

#include "stanly-assert.h"
#include "tree_sitter/api.h"

// generated by stanly::generate_tree_sitter_symbols()

extern "C" {
TSLanguage*
tree_sitter_python(void);
}

namespace stanly {

TSSymbol
lookup_symbol(std::string_view name);
TSFieldId
lookup_field(std::string_view name);

struct fields {
  TSFieldId left = lookup_field("left");
  TSFieldId right = lookup_field("right");
  TSFieldId key = lookup_field("key");
  TSFieldId value = lookup_field("value");
  TSFieldId subscript = lookup_field("subscript");
  TSFieldId alias = lookup_field("alias");
  TSFieldId children = lookup_field("children");
  TSFieldId argument = lookup_field("argument");
} const fields{};
)";

  const std::string postamble = R"(};
// clang-format on

std::string
generate_tree_sitter_symbols();
}  // namespace stanly
)";
  static constexpr const char* fmt = "{} // clang-format off\ninline void\ncheck_symbols() {}\n{}";
  std::vector types = {"_simple_statement", "_compound_statement", "expression_statement",
                       "dictionary", "expression"};
  auto left_sum = [](auto&& x, auto&& y) { return std::get<0>(x) + std::get<0>(y); };
  auto right_sum = [](auto&& x, auto&& y) { return std::get<1>(x) + std::get<1>(y); };
  auto f = [&](auto&& a, auto&& x) { return std::tuple{left_sum(a, x), right_sum(a, x)}; };
  auto enums = std::apply(
      [](auto&& enum_str, auto&& check_str) { return std::format(fmt, enum_str, "{", check_str); },
      reduce(types | vw::transform([&](auto&& tp) { return make_enum(node_types_json, tp); }), f));

  return std::format("{}\n{}{}", preamble, enums, postamble);
}

TSSymbol
lookup_symbol(std::string_view name) {
  return ts_language_symbol_for_name(tree_sitter_python(), name.data(), name.length(), true);
}
TSFieldId
lookup_field(std::string_view name) {
  return ts_language_field_id_for_name(tree_sitter_python(), name.data(), name.size());
}

}  // namespace stanly