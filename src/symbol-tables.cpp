#include "symbol-tables.h"

#include <__ranges/concepts.h>
#include <__ranges/join_view.h>

#include <cstdlib>
#include <iostream>
#include <map>
#include <numeric>
#include <ranges>
#include <set>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>

namespace stanly {

namespace rg = std::ranges;
namespace vw = rg::views;
std::string
process(std::string_view command) {
  std::array<char, 1024> buffer{};
  std::string out;
  FILE* pipe = popen(command.data(), "r");
  if (pipe == nullptr) {
    std::cerr << "Failed to create pipe.\n";
    std::exit(1);
  }
  while (size_t bytes = std::fread(buffer.data(), 1, buffer.size(), pipe)) {
    out.append(buffer.data(), bytes);
  }
  pclose(pipe);
  return out;
}

std::vector<std::string>
split(const std::string& str, const char sep = '\n') {
  std::vector<std::string> out;
  std::stringstream ss{str};
  for (std::string el; std::getline(ss, el, sep);) { out.push_back(el); }
  return out;
}

template <class Result>
Result
to(auto&& range) {
  Result out{};
  for (const auto& e : range) {
    if constexpr (requires { out.push_back(e); }) {
      out.push_back(e);
    } else {
      out.insert(e);
    }
  }
  return out;
}

template <class Range>
std::vector<rg::range_value_t<Range>>
to_vec(Range&& range) {
  return to<std::vector<rg::range_value_t<Range>>>(std::forward<Range>(range));
}

auto
reduce(auto&& range, auto&& f) {
  return std::accumulate(rg::begin(range), rg::end(range), rg::range_value_t<decltype(range)>{}, f);
}

std::vector<std::string>
all_tree_sitter_dependent_nodes(std::string_view node_types_json, std::string_view tp) {
  static constexpr const char* fmt = "< {} jq -r '.[] | select(.type==\"{}\") | {}' 2>/dev/null";
  auto call_jq = [&](auto q) { return split(process(std::format(fmt, node_types_json, tp, q))); };
  auto queries = std::vector{".subtypes[].type", ".children.types[].type"};
  return to_vec(queries | vw::transform(call_jq) | vw::join);
}

std::tuple<std::string, std::string>
make_enum(const std::vector<std::string>& items, std::string name) {
  name = name[0] == '_' ? name.substr(1, name.size() - 1) : name;
  static constexpr const char* f1 =
      "  stanly_assert(static_cast<TSSymbol>({}::{}) == lookup_symbol(\"{}\"));\n";
  static constexpr const char* f2 = "'{}' not a symbol.";
  static constexpr const char* f3 = "  {} = {},\n";
  static constexpr const char* f4 = "enum class {} {}\n{}{};\n";
  rg::for_each(items, [](auto&& s) { stanly_assert(lookup_symbol(s), std::format(f2, s)); });
  std::set<std::string> kewywords{"true", "false", "int", "float"};
  auto kw = [&](const std::string& s) { return kewywords.contains(s) ? "s_" + s : s; };
  auto concat = [](auto&& r) { return std::reduce(rg::begin(r), rg::end(r)); };

  auto range = items | vw::filter([](auto&& s) { return s != "primary_expression"; }) |
               vw::transform([](auto&& s) {
                 return std::pair{lookup_symbol(s), s};
               });
  auto map = to<std::map<TSSymbol, std::string>>(range);
  auto checks =
      map | vw::transform([&](auto&& p) { return std::format(f1, name, kw(p.second), p.second); });
  auto enums =
      map | vw::transform([&](auto&& p) { return std::format(f3, kw(p.second), p.first); });
  return {std::format(f4, name, "{", concat(enums), "}"), concat(checks)};
}

std::tuple<std::string, std::string>
make_enum(std::string_view node_types_json, std::string_view name) {
  auto nodes = std::bind_front(all_tree_sitter_dependent_nodes, node_types_json);
  auto items = nodes(name);
  if (name == "expression") { rg::move(nodes("primary_expression"), std::back_inserter(items)); }
  return make_enum(items, std::string{name});
};

std::string
generate_tree_sitter_symbols(std::string_view node_types_json) {
  const std::string preamble = R"(#pragma once

#include <string_view>

#include "stanly-assert.h"
#include "tree_sitter/api.h"

// generated by stanly::generate_tree_sitter_symbols()

extern "C" {
TSLanguage*
tree_sitter_python(void);
}

namespace stanly {

TSSymbol
lookup_symbol(std::string_view name);
TSFieldId
lookup_field(std::string_view name);

struct fields {
  TSFieldId left = lookup_field("left");
  TSFieldId right = lookup_field("right");
  TSFieldId key = lookup_field("key");
  TSFieldId value = lookup_field("value");
  TSFieldId subscript = lookup_field("subscript");
  TSFieldId alias = lookup_field("alias");
  TSFieldId children = lookup_field("children");
  TSFieldId argument = lookup_field("argument");
} const fields{};
)";

  const std::string postamble = R"(};
// clang-format on

std::string
generate_tree_sitter_symbols();
}  // namespace stanly
)";
  static constexpr const char* fmt = "{} // clang-format off\ninline void\ncheck_symbols() {}\n{}";
  std::vector types = {"_simple_statement", "_compound_statement", "expression_statement",
                       "dictionary", "expression"};
  auto left_sum = [](auto&& x, auto&& y) { return std::get<0>(x) + std::get<0>(y); };
  auto right_sum = [](auto&& x, auto&& y) { return std::get<1>(x) + std::get<1>(y); };
  auto f = [&](auto&& a, auto&& x) { return std::tuple{left_sum(a, x), right_sum(a, x)}; };
  auto enums = std::apply(
      [](auto&& enum_str, auto&& check_str) { return std::format(fmt, enum_str, "{", check_str); },
      reduce(types | vw::transform([&](auto&& tp) { return make_enum(node_types_json, tp); }), f));

  return std::format("{}\n{}{}", preamble, enums, postamble);
}

TSSymbol
lookup_symbol(std::string_view name) {
  return ts_language_symbol_for_name(tree_sitter_python(), name.data(), name.length(), true);
}
TSFieldId
lookup_field(std::string_view name) {
  return ts_language_field_id_for_name(tree_sitter_python(), name.data(), name.size());
}

}  // namespace stanly