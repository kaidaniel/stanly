#pragma once
#include <string_view>
#include <utility>

// generated by "./generate_parser_skeleton.sh build-default/tree-sitter-python/src/node-types.json
// "

namespace stanly::parser {

enum class fields;
struct parser;

std::optional<std::string_view> parse_field(parser&, enum fields);
std::optional<std::string_view> parse_children(parser&);

enum class fields {
  sym_alias = 1,
  sym_alternative = 2,
  sym_argument = 3,
  sym_arguments = 4,
  sym_attribute = 5,
  sym_body = 6,
  sym_cause = 7,
  sym_code = 8,
  sym_condition = 9,
  sym_consequence = 10,
  sym_definition = 11,
  sym_function = 12,
  sym_guard = 13,
  sym_key = 14,
  sym_left = 15,
  sym_module_name = 16,
  sym_name = 17,
  sym_object = 18,
  sym_operator = 19,
  sym_operators = 20,
  sym_parameters = 21,
  sym_pattern = 22,
  sym_return_type = 23,
  sym_right = 24,
  sym_subject = 25,
  sym_subscript = 26,
  sym_superclasses = 27,
  sym_type = 28,
  sym_value = 29,
};

void parse__compound_statement(parser&);
void parse__simple_statement(parser&);
void parse_expression(parser&);
void parse_parameter(parser&);
void parse_pattern(parser&);
void parse_primary_expression(parser&);
void parse_aliased_import(parser&);
void parse_argument_list(parser&);
void parse_as_pattern(parser&);
void parse_assert_statement(parser&);
void parse_assignment(parser&);
void parse_attribute(parser&);
void parse_augmented_assignment(parser&);
void parse_await(parser&);
void parse_binary_operator(parser&);
void parse_block(parser&);
void parse_boolean_operator(parser&);
void parse_break_statement(parser&);
void parse_call(parser&);
void parse_case_clause(parser&);
void parse_case_pattern(parser&);
void parse_chevron(parser&);
void parse_class_definition(parser&);
void parse_comparison_operator(parser&);
void parse_concatenated_string(parser&);
void parse_conditional_expression(parser&);
void parse_continue_statement(parser&);
void parse_decorated_definition(parser&);
void parse_decorator(parser&);
void parse_default_parameter(parser&);
void parse_delete_statement(parser&);
void parse_dictionary(parser&);
void parse_dictionary_comprehension(parser&);
void parse_dictionary_splat(parser&);
void parse_dictionary_splat_pattern(parser&);
void parse_dotted_name(parser&);
void parse_elif_clause(parser&);
void parse_else_clause(parser&);
void parse_except_clause(parser&);
void parse_exec_statement(parser&);
void parse_expression_list(parser&);
void parse_expression_statement(parser&);
void parse_finally_clause(parser&);
void parse_for_in_clause(parser&);
void parse_for_statement(parser&);
void parse_format_expression(parser&);
void parse_format_specifier(parser&);
void parse_function_definition(parser&);
void parse_future_import_statement(parser&);
void parse_generator_expression(parser&);
void parse_global_statement(parser&);
void parse_if_clause(parser&);
void parse_if_statement(parser&);
void parse_import_from_statement(parser&);
void parse_import_prefix(parser&);
void parse_import_statement(parser&);
void parse_interpolation(parser&);
void parse_keyword_argument(parser&);
void parse_keyword_separator(parser&);
void parse_lambda(parser&);
void parse_lambda_parameters(parser&);
void parse_list(parser&);
void parse_list_comprehension(parser&);
void parse_list_pattern(parser&);
void parse_list_splat(parser&);
void parse_list_splat_pattern(parser&);
void parse_match_statement(parser&);
void parse_module(parser&);
void parse_named_expression(parser&);
void parse_nonlocal_statement(parser&);
void parse_not_operator(parser&);
void parse_pair(parser&);
void parse_parameters(parser&);
void parse_parenthesized_expression(parser&);
void parse_parenthesized_list_splat(parser&);
void parse_pass_statement(parser&);
void parse_pattern_list(parser&);
void parse_positional_separator(parser&);
void parse_print_statement(parser&);
void parse_raise_statement(parser&);
void parse_relative_import(parser&);
void parse_return_statement(parser&);
void parse_set(parser&);
void parse_set_comprehension(parser&);
void parse_slice(parser&);
void parse_string(parser&);
void parse_subscript(parser&);
void parse_try_statement(parser&);
void parse_tuple(parser&);
void parse_tuple_pattern(parser&);
void parse_type(parser&);
void parse_typed_default_parameter(parser&);
void parse_typed_parameter(parser&);
void parse_unary_operator(parser&);
void parse_while_statement(parser&);
void parse_wildcard_import(parser&);
void parse_with_clause(parser&);
void parse_with_item(parser&);
void parse_with_statement(parser&);
void parse_yield(parser&);
void parse_comment(parser&);
void parse_ellipsis(parser&);
void parse_escape_sequence(parser&);
void parse_false(parser&);
void parse_float(parser&);
void parse_identifier(parser&);
void parse_integer(parser&);
void parse_none(parser&);
void parse_true(parser&);
void parse_type_conversion(parser&);
}  // namespace stanly::parser
