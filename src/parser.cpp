#include "parser.hpp"

// generated using "generate_parser_symbols.sh"
// nodes_json="build-default/tree-sitter-python/src/node-types.json"
// lookup_symbols="build-default/src/lookup-symbols"

namespace stanly::parser {

void
f();
// clang-format off
namespace _compound_statement { void parse(parser& p); }
namespace _simple_statement { void parse(parser& p); }
namespace expression { void parse(parser& p); }
namespace parameter { void parse(parser& p); }
namespace pattern { void parse(parser& p); }
namespace primary_expression { void parse(parser& p); }
namespace aliased_import { void parse(parser& p); }
namespace argument_list { void parse(parser& p); }
namespace as_pattern { void parse(parser& p); }
namespace assert_statement { void parse(parser& p); }
namespace assignment { void parse(parser& p); }
namespace attribute { void parse(parser& p); }
namespace augmented_assignment { void parse(parser& p); }
namespace await { void parse(parser& p); }
namespace binary_operator { void parse(parser& p); }
namespace block { void parse(parser& p); }
namespace boolean_operator { void parse(parser& p); }
namespace call { void parse(parser& p); }
namespace case_clause { void parse(parser& p); }
namespace case_pattern { void parse(parser& p); }
namespace chevron { void parse(parser& p); }
namespace class_definition { void parse(parser& p); }
namespace comparison_operator { void parse(parser& p); }
namespace concatenated_string { void parse(parser& p); }
namespace conditional_expression { void parse(parser& p); }
namespace decorated_definition { void parse(parser& p); }
namespace decorator { void parse(parser& p); }
namespace default_parameter { void parse(parser& p); }
namespace delete_statement { void parse(parser& p); }
namespace dictionary { void parse(parser& p); }
namespace dictionary_comprehension { void parse(parser& p); }
namespace dictionary_splat { void parse(parser& p); }
namespace dictionary_splat_pattern { void parse(parser& p); }
namespace dotted_name { void parse(parser& p); }
namespace elif_clause { void parse(parser& p); }
namespace else_clause { void parse(parser& p); }
namespace except_clause { void parse(parser& p); }
namespace exec_statement { void parse(parser& p); }
namespace expression_list { void parse(parser& p); }
namespace expression_statement { void parse(parser& p); }
namespace finally_clause { void parse(parser& p); }
namespace for_in_clause { void parse(parser& p); }
namespace for_statement { void parse(parser& p); }
namespace format_expression { void parse(parser& p); }
namespace format_specifier { void parse(parser& p); }
namespace function_definition { void parse(parser& p); }
namespace future_import_statement { void parse(parser& p); }
namespace generator_expression { void parse(parser& p); }
namespace global_statement { void parse(parser& p); }
namespace if_clause { void parse(parser& p); }
namespace if_statement { void parse(parser& p); }
namespace import_from_statement { void parse(parser& p); }
namespace import_statement { void parse(parser& p); }
namespace interpolation { void parse(parser& p); }
namespace keyword_argument { void parse(parser& p); }
namespace lambda { void parse(parser& p); }
namespace lambda_parameters { void parse(parser& p); }
namespace list { void parse(parser& p); }
namespace list_comprehension { void parse(parser& p); }
namespace list_pattern { void parse(parser& p); }
namespace list_splat { void parse(parser& p); }
namespace list_splat_pattern { void parse(parser& p); }
namespace match_statement { void parse(parser& p); }
namespace module { void parse(parser& p); }
namespace named_expression { void parse(parser& p); }
namespace nonlocal_statement { void parse(parser& p); }
namespace not_operator { void parse(parser& p); }
namespace pair { void parse(parser& p); }
namespace parameters { void parse(parser& p); }
namespace parenthesized_expression { void parse(parser& p); }
namespace parenthesized_list_splat { void parse(parser& p); }
namespace pattern_list { void parse(parser& p); }
namespace print_statement { void parse(parser& p); }
namespace raise_statement { void parse(parser& p); }
namespace relative_import { void parse(parser& p); }
namespace return_statement { void parse(parser& p); }
namespace set { void parse(parser& p); }
namespace set_comprehension { void parse(parser& p); }
namespace slice { void parse(parser& p); }
namespace string { void parse(parser& p); }
namespace subscript { void parse(parser& p); }
namespace try_statement { void parse(parser& p); }
namespace tuple { void parse(parser& p); }
namespace tuple_pattern { void parse(parser& p); }
namespace type { void parse(parser& p); }
namespace typed_default_parameter { void parse(parser& p); }
namespace typed_parameter { void parse(parser& p); }
namespace unary_operator { void parse(parser& p); }
namespace while_statement { void parse(parser& p); }
namespace with_clause { void parse(parser& p); }
namespace with_item { void parse(parser& p); }
namespace with_statement { void parse(parser& p); }
namespace yield { void parse(parser& p); }
// clang-format on
}  // namespace stanly::parser
