#include "parser.hpp"

#include <utility>

#include "cursor.hpp"
#include "parse-symbols.hpp"
#include "syntax.h"

// generated by "./generate-parser.sh build-default/tree-sitter-python/src/node-types.json "

namespace stanly {

void
parse_descendants(cursor& c, program& p, auto&& f_child, auto&& f_field) {
  if (goto_child(c)) {
    do {
      parser_trampoline(c, p);
      auto field = current_field(c);
      auto text = current_text(c);
      if (field) {
        f_field(*field, text);
      } else {
        f_child(current_symbol(c), text);
      }
    } while (goto_sibling(c));
    goto_parent(c);
  }
}
template <class F>
  requires requires(F f, symbol sym, std::string_view text) { f(sym, text); }
void
parse_descendants(cursor& c, program& p, F&& f_child) {
  parse_descendants(c, p, f_child, [](field, std::string_view) { throw "unreachable"; });
}
template <class F>
  requires requires(F f, field fld, std::string_view text) { f(fld, text); }
void
parse_descendants(cursor& c, program& p, F&& f_field) {
  parse_descendants(
      c, p, [](symbol, std::string_view) { throw "unreachable"; }, f_field);
}
void
parse_descendants(cursor& c, program& p) {
  parse_descendants(c, p, [&](field, std::string_view) { throw "unreachable"; });
}

void
parser_trampoline(cursor& c, program& p) {
  using enum symbol;
  using enum field;
  switch (current_symbol(c)) {
    case sym_aliased_import: {
      std::string_view field_alias;
      std::string_view field_name;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_alias: field_alias = h; break;
              case fld_name: field_name = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_aliased_import(p, field_alias, field_name);
      return;
    }
    case sym_argument_list: {
      std::optional<std::string_view> child_dictionary_splat = std::nullopt;
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_keyword_argument = std::nullopt;
      std::optional<std::string_view> child_list_splat = std::nullopt;
      std::optional<std::string_view> child_parenthesized_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_dictionary_splat: child_dictionary_splat = h; break;
              case sym_keyword_argument: child_keyword_argument = h; break;
              case sym_list_splat: child_list_splat = h; break;
              case sym_parenthesized_expression: child_parenthesized_expression = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_argument_list(
          p, child_dictionary_splat, child_expression, child_keyword_argument, child_list_splat,
          child_parenthesized_expression);
      return;
    }
    case sym_as_pattern: {
      std::optional<std::string_view> child_expression = std::nullopt;

      std::string_view field_alias;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_alias: field_alias = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_as_pattern(p, child_expression, field_alias);
      return;
    }
    case sym_assert_statement: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_assert_statement(p, child_expression);
      return;
    }
    case sym_assignment: {
      std::optional<std::string_view> field_right = std::nullopt;
      std::optional<std::string_view> field_type = std::nullopt;
      std::string_view field_left;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_left: field_left = h; break;
              case fld_right: field_right = h; break;
              case fld_type: field_type = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_assignment(p, field_right, field_type, field_left);
      return;
    }
    case sym_attribute: {
      std::string_view field_attribute;
      std::string_view field_object;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_attribute: field_attribute = h; break;
              case fld_object: field_object = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_attribute(p, field_attribute, field_object);
      return;
    }
    case sym_augmented_assignment: {
      std::string_view field_left;
      std::string_view field_operator;
      std::string_view field_right;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_left: field_left = h; break;
              case fld_operator: field_operator = h; break;
              case fld_right: field_right = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_augmented_assignment(p, field_left, field_operator, field_right);
      return;
    }
    case sym_await: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_await(p, child_expression);
      return;
    }
    case sym_binary_operator: {
      std::string_view field_left;
      std::string_view field_operator;
      std::string_view field_right;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_left: field_left = h; break;
              case fld_operator: field_operator = h; break;
              case fld_right: field_right = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_binary_operator(p, field_left, field_operator, field_right);
      return;
    }
    case sym_block: {
      std::optional<std::string_view> child__compound_statement = std::nullopt;
      std::optional<std::string_view> child__simple_statement = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_block(p, child__compound_statement, child__simple_statement);
      return;
    }
    case sym_boolean_operator: {
      std::string_view field_left;
      std::string_view field_operator;
      std::string_view field_right;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_left: field_left = h; break;
              case fld_operator: field_operator = h; break;
              case fld_right: field_right = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_boolean_operator(p, field_left, field_operator, field_right);
      return;
    }
    case sym_break_statement: {
      parse_descendants(
          c, p

      );

      parse_sym_break_statement(p);
      return;
    }
    case sym_call: {
      std::string_view field_arguments;
      std::string_view field_function;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_arguments: field_arguments = h; break;
              case fld_function: field_function = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_call(p, field_arguments, field_function);
      return;
    }
    case sym_case_clause: {
      std::optional<std::string_view> field_guard = std::nullopt;
      std::string_view field_consequence;
      std::string_view field_pattern;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_consequence: field_consequence = h; break;
              case fld_guard: field_guard = h; break;
              case fld_pattern: field_pattern = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_case_clause(p, field_guard, field_consequence, field_pattern);
      return;
    }
    case sym_case_pattern: {
      std::optional<std::string_view> child_attribute = std::nullopt;
      std::optional<std::string_view> child_identifier = std::nullopt;
      std::optional<std::string_view> child_subscript = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_attribute: child_attribute = h; break;
              case sym_identifier: child_identifier = h; break;
              case sym_subscript: child_subscript = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_case_pattern(p, child_attribute, child_identifier, child_subscript);
      return;
    }
    case sym_chevron: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_chevron(p, child_expression);
      return;
    }
    case sym_class_definition: {
      std::optional<std::string_view> field_superclasses = std::nullopt;
      std::string_view field_body;
      std::string_view field_name;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              case fld_name: field_name = h; break;
              case fld_superclasses: field_superclasses = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_class_definition(p, field_superclasses, field_body, field_name);
      return;
    }
    case sym_comparison_operator: {
      std::optional<std::string_view> child_primary_expression = std::nullopt;

      std::string_view field_operators;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_operators: field_operators = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_comparison_operator(p, child_primary_expression, field_operators);
      return;
    }
    case sym_concatenated_string: {
      std::optional<std::string_view> child_string = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_string: child_string = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_concatenated_string(p, child_string);
      return;
    }
    case sym_conditional_expression: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_conditional_expression(p, child_expression);
      return;
    }
    case sym_continue_statement: {
      parse_descendants(
          c, p

      );

      parse_sym_continue_statement(p);
      return;
    }
    case sym_decorated_definition: {
      std::optional<std::string_view> child_decorator = std::nullopt;

      std::string_view field_definition;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_decorator: child_decorator = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_definition: field_definition = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_decorated_definition(p, child_decorator, field_definition);
      return;
    }
    case sym_decorator: {
      std::optional<std::string_view> child_primary_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_decorator(p, child_primary_expression);
      return;
    }
    case sym_default_parameter: {
      std::string_view field_name;
      std::string_view field_value;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_name: field_name = h; break;
              case fld_value: field_value = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_default_parameter(p, field_name, field_value);
      return;
    }
    case sym_delete_statement: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_expression_list = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_expression_list: child_expression_list = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_delete_statement(p, child_expression, child_expression_list);
      return;
    }
    case sym_dictionary: {
      std::optional<std::string_view> child_dictionary_splat = std::nullopt;
      std::optional<std::string_view> child_pair = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_dictionary_splat: child_dictionary_splat = h; break;
              case sym_pair: child_pair = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_dictionary(p, child_dictionary_splat, child_pair);
      return;
    }
    case sym_dictionary_comprehension: {
      std::optional<std::string_view> child_for_in_clause = std::nullopt;
      std::optional<std::string_view> child_if_clause = std::nullopt;

      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_for_in_clause: child_for_in_clause = h; break;
              case sym_if_clause: child_if_clause = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_dictionary_comprehension(p, child_for_in_clause, child_if_clause, field_body);
      return;
    }
    case sym_dictionary_splat: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_dictionary_splat(p, child_expression);
      return;
    }
    case sym_dictionary_splat_pattern: {
      std::optional<std::string_view> child_attribute = std::nullopt;
      std::optional<std::string_view> child_identifier = std::nullopt;
      std::optional<std::string_view> child_subscript = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_attribute: child_attribute = h; break;
              case sym_identifier: child_identifier = h; break;
              case sym_subscript: child_subscript = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_dictionary_splat_pattern(p, child_attribute, child_identifier, child_subscript);
      return;
    }
    case sym_dotted_name: {
      std::optional<std::string_view> child_identifier = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_identifier: child_identifier = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_dotted_name(p, child_identifier);
      return;
    }
    case sym_elif_clause: {
      std::string_view field_condition;
      std::string_view field_consequence;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_condition: field_condition = h; break;
              case fld_consequence: field_consequence = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_elif_clause(p, field_condition, field_consequence);
      return;
    }
    case sym_else_clause: {
      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_else_clause(p, field_body);
      return;
    }
    case sym_except_clause: {
      std::optional<std::string_view> child_block = std::nullopt;
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_block: child_block = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_except_clause(p, child_block, child_expression);
      return;
    }
    case sym_exec_statement: {
      std::optional<std::string_view> child_expression = std::nullopt;

      std::string_view field_code;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_code: field_code = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_exec_statement(p, child_expression, field_code);
      return;
    }
    case sym_expression_list: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_expression_list(p, child_expression);
      return;
    }
    case sym_expression_statement: {
      std::optional<std::string_view> child_assignment = std::nullopt;
      std::optional<std::string_view> child_augmented_assignment = std::nullopt;
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_yield = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_assignment: child_assignment = h; break;
              case sym_augmented_assignment: child_augmented_assignment = h; break;
              case sym_yield: child_yield = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_expression_statement(
          p, child_assignment, child_augmented_assignment, child_expression, child_yield);
      return;
    }
    case sym_finally_clause: {
      std::optional<std::string_view> child_block = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_block: child_block = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_finally_clause(p, child_block);
      return;
    }
    case sym_for_in_clause: {
      std::string_view field_left;
      std::string_view field_right;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_left: field_left = h; break;
              case fld_right: field_right = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_for_in_clause(p, field_left, field_right);
      return;
    }
    case sym_for_statement: {
      std::optional<std::string_view> field_alternative = std::nullopt;
      std::string_view field_body;
      std::string_view field_left;
      std::string_view field_right;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_alternative: field_alternative = h; break;
              case fld_body: field_body = h; break;
              case fld_left: field_left = h; break;
              case fld_right: field_right = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_for_statement(p, field_alternative, field_body, field_left, field_right);
      return;
    }
    case sym_format_expression: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_format_expression(p, child_expression);
      return;
    }
    case sym_format_specifier: {
      std::optional<std::string_view> child_format_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_format_expression: child_format_expression = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_format_specifier(p, child_format_expression);
      return;
    }
    case sym_function_definition: {
      std::optional<std::string_view> field_return_type = std::nullopt;
      std::string_view field_body;
      std::string_view field_name;
      std::string_view field_parameters;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              case fld_name: field_name = h; break;
              case fld_parameters: field_parameters = h; break;
              case fld_return_type: field_return_type = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_function_definition(p, field_return_type, field_body, field_name, field_parameters);
      return;
    }
    case sym_future_import_statement: {
      std::string_view field_name;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_name: field_name = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_future_import_statement(p, field_name);
      return;
    }
    case sym_generator_expression: {
      std::optional<std::string_view> child_for_in_clause = std::nullopt;
      std::optional<std::string_view> child_if_clause = std::nullopt;

      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_for_in_clause: child_for_in_clause = h; break;
              case sym_if_clause: child_if_clause = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_generator_expression(p, child_for_in_clause, child_if_clause, field_body);
      return;
    }
    case sym_global_statement: {
      std::optional<std::string_view> child_identifier = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_identifier: child_identifier = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_global_statement(p, child_identifier);
      return;
    }
    case sym_if_clause: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_if_clause(p, child_expression);
      return;
    }
    case sym_if_statement: {
      std::optional<std::string_view> field_alternative = std::nullopt;
      std::string_view field_condition;
      std::string_view field_consequence;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_alternative: field_alternative = h; break;
              case fld_condition: field_condition = h; break;
              case fld_consequence: field_consequence = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_if_statement(p, field_alternative, field_condition, field_consequence);
      return;
    }
    case sym_import_from_statement: {
      std::optional<std::string_view> child_wildcard_import = std::nullopt;
      std::optional<std::string_view> field_name = std::nullopt;
      std::string_view field_module_name;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_wildcard_import: child_wildcard_import = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_module_name: field_module_name = h; break;
              case fld_name: field_name = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_import_from_statement(p, child_wildcard_import, field_name, field_module_name);
      return;
    }
    case sym_import_prefix: {
      parse_descendants(
          c, p

      );

      parse_sym_import_prefix(p);
      return;
    }
    case sym_import_statement: {
      std::string_view field_name;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_name: field_name = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_import_statement(p, field_name);
      return;
    }
    case sym_interpolation: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_format_specifier = std::nullopt;
      std::optional<std::string_view> child_type_conversion = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_format_specifier: child_format_specifier = h; break;
              case sym_type_conversion: child_type_conversion = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_interpolation(p, child_expression, child_format_specifier, child_type_conversion);
      return;
    }
    case sym_keyword_argument: {
      std::string_view field_name;
      std::string_view field_value;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_name: field_name = h; break;
              case fld_value: field_value = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_keyword_argument(p, field_name, field_value);
      return;
    }
    case sym_keyword_separator: {
      parse_descendants(
          c, p

      );

      parse_sym_keyword_separator(p);
      return;
    }
    case sym_lambda: {
      std::optional<std::string_view> field_parameters = std::nullopt;
      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              case fld_parameters: field_parameters = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_lambda(p, field_parameters, field_body);
      return;
    }
    case sym_lambda_parameters: {
      std::optional<std::string_view> child_parameter = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_lambda_parameters(p, child_parameter);
      return;
    }
    case sym_list: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_list_splat = std::nullopt;
      std::optional<std::string_view> child_parenthesized_list_splat = std::nullopt;
      std::optional<std::string_view> child_yield = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_list_splat: child_list_splat = h; break;
              case sym_parenthesized_list_splat: child_parenthesized_list_splat = h; break;
              case sym_yield: child_yield = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_list(
          p, child_expression, child_list_splat, child_parenthesized_list_splat, child_yield);
      return;
    }
    case sym_list_comprehension: {
      std::optional<std::string_view> child_for_in_clause = std::nullopt;
      std::optional<std::string_view> child_if_clause = std::nullopt;

      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_for_in_clause: child_for_in_clause = h; break;
              case sym_if_clause: child_if_clause = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_list_comprehension(p, child_for_in_clause, child_if_clause, field_body);
      return;
    }
    case sym_list_pattern: {
      std::optional<std::string_view> child_pattern = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_list_pattern(p, child_pattern);
      return;
    }
    case sym_list_splat: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_list_splat(p, child_expression);
      return;
    }
    case sym_list_splat_pattern: {
      std::optional<std::string_view> child_attribute = std::nullopt;
      std::optional<std::string_view> child_identifier = std::nullopt;
      std::optional<std::string_view> child_subscript = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_attribute: child_attribute = h; break;
              case sym_identifier: child_identifier = h; break;
              case sym_subscript: child_subscript = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_list_splat_pattern(p, child_attribute, child_identifier, child_subscript);
      return;
    }
    case sym_match_statement: {
      std::optional<std::string_view> field_alternative = std::nullopt;
      std::string_view field_subject;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_alternative: field_alternative = h; break;
              case fld_subject: field_subject = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_match_statement(p, field_alternative, field_subject);
      return;
    }
    case sym_module: {
      std::optional<std::string_view> child__compound_statement = std::nullopt;
      std::optional<std::string_view> child__simple_statement = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_module(p, child__compound_statement, child__simple_statement);
      return;
    }
    case sym_named_expression: {
      std::string_view field_name;
      std::string_view field_value;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_name: field_name = h; break;
              case fld_value: field_value = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_named_expression(p, field_name, field_value);
      return;
    }
    case sym_nonlocal_statement: {
      std::optional<std::string_view> child_identifier = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_identifier: child_identifier = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_nonlocal_statement(p, child_identifier);
      return;
    }
    case sym_not_operator: {
      std::string_view field_argument;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_argument: field_argument = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_not_operator(p, field_argument);
      return;
    }
    case sym_pair: {
      std::string_view field_key;
      std::string_view field_value;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_key: field_key = h; break;
              case fld_value: field_value = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_pair(p, field_key, field_value);
      return;
    }
    case sym_parameters: {
      std::optional<std::string_view> child_parameter = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_parameters(p, child_parameter);
      return;
    }
    case sym_parenthesized_expression: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_list_splat = std::nullopt;
      std::optional<std::string_view> child_parenthesized_expression = std::nullopt;
      std::optional<std::string_view> child_yield = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_list_splat: child_list_splat = h; break;
              case sym_parenthesized_expression: child_parenthesized_expression = h; break;
              case sym_yield: child_yield = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_parenthesized_expression(
          p, child_expression, child_list_splat, child_parenthesized_expression, child_yield);
      return;
    }
    case sym_parenthesized_list_splat: {
      std::optional<std::string_view> child_list_splat = std::nullopt;
      std::optional<std::string_view> child_parenthesized_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_list_splat: child_list_splat = h; break;
              case sym_parenthesized_expression: child_parenthesized_expression = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_parenthesized_list_splat(p, child_list_splat, child_parenthesized_expression);
      return;
    }
    case sym_pass_statement: {
      parse_descendants(
          c, p

      );

      parse_sym_pass_statement(p);
      return;
    }
    case sym_pattern_list: {
      std::optional<std::string_view> child_pattern = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_pattern_list(p, child_pattern);
      return;
    }
    case sym_positional_separator: {
      parse_descendants(
          c, p

      );

      parse_sym_positional_separator(p);
      return;
    }
    case sym_print_statement: {
      std::optional<std::string_view> child_chevron = std::nullopt;
      std::optional<std::string_view> field_argument = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_chevron: child_chevron = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_argument: field_argument = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_print_statement(p, child_chevron, field_argument);
      return;
    }
    case sym_raise_statement: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_expression_list = std::nullopt;
      std::optional<std::string_view> field_cause = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_expression_list: child_expression_list = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_cause: field_cause = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_raise_statement(p, child_expression, child_expression_list, field_cause);
      return;
    }
    case sym_relative_import: {
      std::optional<std::string_view> child_dotted_name = std::nullopt;
      std::optional<std::string_view> child_import_prefix = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_dotted_name: child_dotted_name = h; break;
              case sym_import_prefix: child_import_prefix = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_relative_import(p, child_dotted_name, child_import_prefix);
      return;
    }
    case sym_return_statement: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_expression_list = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_expression_list: child_expression_list = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_return_statement(p, child_expression, child_expression_list);
      return;
    }
    case sym_set: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_list_splat = std::nullopt;
      std::optional<std::string_view> child_parenthesized_list_splat = std::nullopt;
      std::optional<std::string_view> child_yield = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_list_splat: child_list_splat = h; break;
              case sym_parenthesized_list_splat: child_parenthesized_list_splat = h; break;
              case sym_yield: child_yield = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_set(
          p, child_expression, child_list_splat, child_parenthesized_list_splat, child_yield);
      return;
    }
    case sym_set_comprehension: {
      std::optional<std::string_view> child_for_in_clause = std::nullopt;
      std::optional<std::string_view> child_if_clause = std::nullopt;

      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_for_in_clause: child_for_in_clause = h; break;
              case sym_if_clause: child_if_clause = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_set_comprehension(p, child_for_in_clause, child_if_clause, field_body);
      return;
    }
    case sym_slice: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_slice(p, child_expression);
      return;
    }
    case sym_string: {
      std::optional<std::string_view> child_escape_sequence = std::nullopt;
      std::optional<std::string_view> child_interpolation = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_escape_sequence: child_escape_sequence = h; break;
              case sym_interpolation: child_interpolation = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_string(p, child_escape_sequence, child_interpolation);
      return;
    }
    case sym_subscript: {
      std::string_view field_subscript;
      std::string_view field_value;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_subscript: field_subscript = h; break;
              case fld_value: field_value = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_subscript(p, field_subscript, field_value);
      return;
    }
    case sym_try_statement: {
      std::optional<std::string_view> child_else_clause = std::nullopt;
      std::optional<std::string_view> child_except_clause = std::nullopt;
      std::optional<std::string_view> child_finally_clause = std::nullopt;

      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_else_clause: child_else_clause = h; break;
              case sym_except_clause: child_except_clause = h; break;
              case sym_finally_clause: child_finally_clause = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_try_statement(
          p, child_else_clause, child_except_clause, child_finally_clause, field_body);
      return;
    }
    case sym_tuple: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_list_splat = std::nullopt;
      std::optional<std::string_view> child_parenthesized_list_splat = std::nullopt;
      std::optional<std::string_view> child_yield = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_list_splat: child_list_splat = h; break;
              case sym_parenthesized_list_splat: child_parenthesized_list_splat = h; break;
              case sym_yield: child_yield = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_tuple(
          p, child_expression, child_list_splat, child_parenthesized_list_splat, child_yield);
      return;
    }
    case sym_tuple_pattern: {
      std::optional<std::string_view> child_pattern = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_tuple_pattern(p, child_pattern);
      return;
    }
    case sym_type: {
      std::optional<std::string_view> child_expression = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              default: throw "unreachable";
            }
          }

      );

      parse_sym_type(p, child_expression);
      return;
    }
    case sym_typed_default_parameter: {
      std::string_view field_name;
      std::string_view field_type;
      std::string_view field_value;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_name: field_name = h; break;
              case fld_type: field_type = h; break;
              case fld_value: field_value = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_typed_default_parameter(p, field_name, field_type, field_value);
      return;
    }
    case sym_typed_parameter: {
      std::optional<std::string_view> child_dictionary_splat_pattern = std::nullopt;
      std::optional<std::string_view> child_identifier = std::nullopt;
      std::optional<std::string_view> child_list_splat_pattern = std::nullopt;

      std::string_view field_type;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_dictionary_splat_pattern: child_dictionary_splat_pattern = h; break;
              case sym_identifier: child_identifier = h; break;
              case sym_list_splat_pattern: child_list_splat_pattern = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_type: field_type = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_typed_parameter(
          p, child_dictionary_splat_pattern, child_identifier, child_list_splat_pattern,
          field_type);
      return;
    }
    case sym_unary_operator: {
      std::string_view field_argument;
      std::string_view field_operator;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_argument: field_argument = h; break;
              case fld_operator: field_operator = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_unary_operator(p, field_argument, field_operator);
      return;
    }
    case sym_while_statement: {
      std::optional<std::string_view> field_alternative = std::nullopt;
      std::string_view field_body;
      std::string_view field_condition;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_alternative: field_alternative = h; break;
              case fld_body: field_body = h; break;
              case fld_condition: field_condition = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_while_statement(p, field_alternative, field_body, field_condition);
      return;
    }
    case sym_wildcard_import: {
      parse_descendants(
          c, p

      );

      parse_sym_wildcard_import(p);
      return;
    }
    case sym_with_clause: {
      std::optional<std::string_view> child_with_item = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_with_item: child_with_item = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_with_clause(p, child_with_item);
      return;
    }
    case sym_with_item: {
      std::string_view field_value;
      parse_descendants(
          c, p,
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_value: field_value = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_with_item(p, field_value);
      return;
    }
    case sym_with_statement: {
      std::optional<std::string_view> child_with_clause = std::nullopt;

      std::string_view field_body;
      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_with_clause: child_with_clause = h; break;
              default: throw "unreachable";
            }
          },
          [&](field f, std::string_view h) {
            switch (f) {
              case fld_body: field_body = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_with_statement(p, child_with_clause, field_body);
      return;
    }
    case sym_yield: {
      std::optional<std::string_view> child_expression = std::nullopt;
      std::optional<std::string_view> child_expression_list = std::nullopt;

      parse_descendants(
          c, p,
          [&](symbol s, std::string_view h) {
            switch (s) {
              case sym_expression_list: child_expression_list = h; break;
              default: throw "unreachable";
            }
          }

      );

      parse_sym_yield(p, child_expression, child_expression_list);
      return;
    }
    case sym_comment: {
      parse_descendants(
          c, p

      );

      parse_sym_comment(p);
      return;
    }
    case sym_ellipsis: {
      parse_descendants(
          c, p

      );

      parse_sym_ellipsis(p);
      return;
    }
    case sym_escape_sequence: {
      parse_descendants(
          c, p

      );

      parse_sym_escape_sequence(p);
      return;
    }
    case sym_false: {
      parse_descendants(
          c, p

      );

      parse_sym_false(p);
      return;
    }
    case sym_float: {
      parse_descendants(
          c, p

      );

      parse_sym_float(p);
      return;
    }
    case sym_identifier: {
      parse_descendants(
          c, p

      );

      parse_sym_identifier(p);
      return;
    }
    case sym_integer: {
      parse_descendants(
          c, p

      );

      parse_sym_integer(p);
      return;
    }
    case sym_none: {
      parse_descendants(
          c, p

      );

      parse_sym_none(p);
      return;
    }
    case sym_true: {
      parse_descendants(
          c, p

      );

      parse_sym_true(p);
      return;
    }
    case sym_type_conversion: {
      parse_descendants(
          c, p

      );

      parse_sym_type_conversion(p);
      return;
    }
  };
  throw "unreachable";
}

}  // namespace stanly
