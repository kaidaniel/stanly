#pragma once

#include "parse-symbols.hpp"

#include <utility>

#include "handle.h"
#include "program.hpp"

// generated by "./generate-parser.sh build-default/tree-sitter-python/src/node-types.json "

namespace stanly {

void parse_sym_aliased_import(program& p, handle fld_alias, handle fld_name){};
void parse_sym_argument_list(
    program& p, std::optional<handle> child_dictionary_splat,
    std::optional<handle> child_expression, std::optional<handle> child_keyword_argument,
    std::optional<handle> child_list_splat, std::optional<handle> child_parenthesized_expression){};
void parse_sym_as_pattern(program& p, std::optional<handle> child_expression, handle fld_alias){};
void parse_sym_assert_statement(program& p, std::optional<handle> child_expression){};
void parse_sym_assignment(
    program& p, std::optional<handle> fld_right, std::optional<handle> fld_type, handle fld_left){};
void parse_sym_attribute(program& p, handle fld_attribute, handle fld_object){};
void parse_sym_augmented_assignment(
    program& p, handle fld_left, handle fld_operator, handle fld_right){};
void parse_sym_await(program& p, std::optional<handle> child_expression){};
void parse_sym_binary_operator(
    program& p, handle fld_left, handle fld_operator, handle fld_right){};
void parse_sym_block(
    program& p, std::optional<handle> child__compound_statement,
    std::optional<handle> child__simple_statement){};
void parse_sym_boolean_operator(
    program& p, handle fld_left, handle fld_operator, handle fld_right){};
void parse_sym_break_statement(program& p){};
void parse_sym_call(program& p, handle fld_arguments, handle fld_function){};
void parse_sym_case_clause(
    program& p, std::optional<handle> fld_guard, handle fld_consequence, handle fld_pattern){};
void parse_sym_case_pattern(
    program& p, std::optional<handle> child_attribute, std::optional<handle> child_identifier,
    std::optional<handle> child_subscript){};
void parse_sym_chevron(program& p, std::optional<handle> child_expression){};
void parse_sym_class_definition(
    program& p, std::optional<handle> fld_superclasses, handle fld_body, handle fld_name){};
void parse_sym_comparison_operator(
    program& p, std::optional<handle> child_primary_expression, handle fld_operators){};
void parse_sym_concatenated_string(program& p, std::optional<handle> child_string){};
void parse_sym_conditional_expression(program& p, std::optional<handle> child_expression){};
void parse_sym_continue_statement(program& p){};
void parse_sym_decorated_definition(
    program& p, std::optional<handle> child_decorator, handle fld_definition){};
void parse_sym_decorator(program& p, std::optional<handle> child_primary_expression){};
void parse_sym_default_parameter(program& p, handle fld_name, handle fld_value){};
void parse_sym_delete_statement(
    program& p, std::optional<handle> child_expression,
    std::optional<handle> child_expression_list){};
void parse_sym_dictionary(
    program& p, std::optional<handle> child_dictionary_splat, std::optional<handle> child_pair){};
void parse_sym_dictionary_comprehension(
    program& p, std::optional<handle> child_for_in_clause, std::optional<handle> child_if_clause,
    handle fld_body){};
void parse_sym_dictionary_splat(program& p, std::optional<handle> child_expression){};
void parse_sym_dictionary_splat_pattern(
    program& p, std::optional<handle> child_attribute, std::optional<handle> child_identifier,
    std::optional<handle> child_subscript){};
void parse_sym_dotted_name(program& p, std::optional<handle> child_identifier){};
void parse_sym_elif_clause(program& p, handle fld_condition, handle fld_consequence){};
void parse_sym_else_clause(program& p, handle fld_body){};
void parse_sym_except_clause(
    program& p, std::optional<handle> child_block, std::optional<handle> child_expression){};
void parse_sym_exec_statement(
    program& p, std::optional<handle> child_expression, handle fld_code){};
void parse_sym_expression_list(program& p, std::optional<handle> child_expression){};
void parse_sym_expression_statement(
    program& p, std::optional<handle> child_assignment,
    std::optional<handle> child_augmented_assignment, std::optional<handle> child_expression,
    std::optional<handle> child_yield){

};
void parse_sym_finally_clause(program& p, std::optional<handle> child_block){};
void parse_sym_for_in_clause(program& p, handle fld_left, handle fld_right){};
void parse_sym_for_statement(
    program& p, std::optional<handle> fld_alternative, handle fld_body, handle fld_left,
    handle fld_right){};
void parse_sym_format_expression(program& p, std::optional<handle> child_expression){};
void parse_sym_format_specifier(program& p, std::optional<handle> child_format_expression){};
void parse_sym_function_definition(
    program& p, std::optional<handle> fld_return_type, handle fld_body, handle fld_name,
    handle fld_parameters){};
void parse_sym_future_import_statement(program& p, handle fld_name){};
void parse_sym_generator_expression(
    program& p, std::optional<handle> child_for_in_clause, std::optional<handle> child_if_clause,
    handle fld_body){};
void parse_sym_global_statement(program& p, std::optional<handle> child_identifier){};
void parse_sym_if_clause(program& p, std::optional<handle> child_expression){};
void parse_sym_if_statement(
    program& p, std::optional<handle> fld_alternative, handle fld_condition,
    handle fld_consequence){};
void parse_sym_import_from_statement(
    program& p, std::optional<handle> child_wildcard_import, std::optional<handle> fld_name,
    handle fld_module_name){};
void parse_sym_import_prefix(program& p){};
void parse_sym_import_statement(program& p, handle fld_name){};
void parse_sym_interpolation(
    program& p, std::optional<handle> child_expression,
    std::optional<handle> child_format_specifier, std::optional<handle> child_type_conversion){};
void parse_sym_keyword_argument(program& p, handle fld_name, handle fld_value){};
void parse_sym_keyword_separator(program& p){};
void parse_sym_lambda(program& p, std::optional<handle> fld_parameters, handle fld_body){};
void parse_sym_lambda_parameters(program& p, std::optional<handle> child_parameter){};
void parse_sym_list(
    program& p, std::optional<handle> child_expression, std::optional<handle> child_list_splat,
    std::optional<handle> child_parenthesized_list_splat, std::optional<handle> child_yield){};
void parse_sym_list_comprehension(
    program& p, std::optional<handle> child_for_in_clause, std::optional<handle> child_if_clause,
    handle fld_body){};
void parse_sym_list_pattern(program& p, std::optional<handle> child_pattern){};
void parse_sym_list_splat(program& p, std::optional<handle> child_expression){};
void parse_sym_list_splat_pattern(
    program& p, std::optional<handle> child_attribute, std::optional<handle> child_identifier,
    std::optional<handle> child_subscript){};
void parse_sym_match_statement(
    program& p, std::optional<handle> fld_alternative, handle fld_subject){};
void parse_sym_module(
    program& p, std::optional<handle> child__compound_statement,
    std::optional<handle> child__simple_statement){/*no-op*/};
void parse_sym_named_expression(program& p, handle fld_name, handle fld_value){};
void parse_sym_nonlocal_statement(program& p, std::optional<handle> child_identifier){};
void parse_sym_not_operator(program& p, handle fld_argument){};
void parse_sym_pair(program& p, handle fld_key, handle fld_value){};
void parse_sym_parameters(program& p, std::optional<handle> child_parameter){};
void parse_sym_parenthesized_expression(
    program& p, std::optional<handle> child_expression, std::optional<handle> child_list_splat,
    std::optional<handle> child_parenthesized_expression, std::optional<handle> child_yield){};
void parse_sym_parenthesized_list_splat(
    program& p, std::optional<handle> child_list_splat,
    std::optional<handle> child_parenthesized_expression){};
void parse_sym_pass_statement(program& p){};
void parse_sym_pattern_list(program& p, std::optional<handle> child_pattern){};
void parse_sym_positional_separator(program& p){};
void parse_sym_print_statement(
    program& p, std::optional<handle> child_chevron, std::optional<handle> fld_argument){};
void parse_sym_raise_statement(
    program& p, std::optional<handle> child_expression, std::optional<handle> child_expression_list,
    std::optional<handle> fld_cause){};
void parse_sym_relative_import(
    program& p, std::optional<handle> child_dotted_name,
    std::optional<handle> child_import_prefix){};
void parse_sym_return_statement(
    program& p, std::optional<handle> child_expression,
    std::optional<handle> child_expression_list){};
void parse_sym_set(
    program& p, std::optional<handle> child_expression, std::optional<handle> child_list_splat,
    std::optional<handle> child_parenthesized_list_splat, std::optional<handle> child_yield){};
void parse_sym_set_comprehension(
    program& p, std::optional<handle> child_for_in_clause, std::optional<handle> child_if_clause,
    handle fld_body){};
void parse_sym_slice(program& p, std::optional<handle> child_expression){};
void parse_sym_string(
    program& p, std::optional<handle> child_escape_sequence,
    std::optional<handle> child_interpolation){};
void parse_sym_subscript(program& p, handle fld_subscript, handle fld_value){};
void parse_sym_try_statement(
    program& p, std::optional<handle> child_else_clause, std::optional<handle> child_except_clause,
    std::optional<handle> child_finally_clause, handle fld_body){};
void parse_sym_tuple(
    program& p, std::optional<handle> child_expression, std::optional<handle> child_list_splat,
    std::optional<handle> child_parenthesized_list_splat, std::optional<handle> child_yield){};
void parse_sym_tuple_pattern(program& p, std::optional<handle> child_pattern){};
void parse_sym_type(program& p, std::optional<handle> child_expression){};
void parse_sym_typed_default_parameter(
    program& p, handle fld_name, handle fld_type, handle fld_value){};
void parse_sym_typed_parameter(
    program& p, std::optional<handle> child_dictionary_splat_pattern,
    std::optional<handle> child_identifier, std::optional<handle> child_list_splat_pattern,
    handle fld_type){};
void parse_sym_unary_operator(program& p, handle fld_argument, handle fld_operator){};
void parse_sym_while_statement(
    program& p, std::optional<handle> fld_alternative, handle fld_body, handle fld_condition){};
void parse_sym_wildcard_import(program& p){};
void parse_sym_with_clause(program& p, std::optional<handle> child_with_item){};
void parse_sym_with_item(program& p, handle fld_value){};
void parse_sym_with_statement(
    program& p, std::optional<handle> child_with_clause, handle fld_body){};
void parse_sym_yield(
    program& p, std::optional<handle> child_expression,
    std::optional<handle> child_expression_list){};
void parse_sym_comment(program& p){};
void parse_sym_ellipsis(program& p){};
void parse_sym_escape_sequence(program& p){};
void parse_sym_false(program& p){};
void parse_sym_float(program& p){};
void parse_sym_identifier(program& p){};
void parse_sym_integer(program& p){};
void parse_sym_none(program& p){};
void parse_sym_true(program& p){};
void parse_sym_type_conversion(program& p){};
}  // namespace stanly
