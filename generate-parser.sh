[[ $1 ]] && nodes_json="$1" || nodes_json="build-default/tree-sitter-python/src/node-types.json"
[[ $2 ]] && lookup_symbols="$2" || lookup_symbols="build-default/src/lookup-symbols"

symbols=$(jq -r -c '.[] | select(.named) | select(.subtypes == null)' < $nodes_json)
name=$(jq -r '"sym_" + .type' <<< $symbols) 
optional_fields=$(jq -r -c '.fields // {} | map_values(select(.required == false)) | keys' <<< $symbols)
required_fields=$(jq -r -c '.fields // {} | map_values(select(.required)) | keys' <<< $symbols)
children=$(jq -r -c '.children.types // [] | [.[].type]' <<< $symbols)
#children=$(jq '. as $json | .[] | [select(.named)] | .[] | select(.subtypes == null) | .children.types // [] | [.[].type as $t | ($json[] | select(.type == $t).subtypes) as $st | if $st==null then $t else $st[].type end]' < $nodes_json)
all_fields=$(jq -r -c '.fields // {} | keys' <<< $symbols)
n_symbols=$(wc -l <<< $symbols)
norca_vars=$(paste -d "^" <(echo "$name") <(echo "$optional_fields") <(echo "$required_fields") <(echo "$children") <(echo "$all_fields") | awk '{ gsub("\[\]", ""); print  }' | tr -d "[]\"")
n=0


cat << CURSOR_HPP > src/cursor.hpp
#pragma once

#include <utility>
#include <string_view>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly {

enum class symbol;
enum class field;
struct cursor;

std::string_view current_text(cursor&);
symbol current_symbol(cursor&);
std::optional<field> current_field(cursor&);

bool goto_child(cursor&);
bool goto_sibling(cursor&);
void goto_parent(cursor&);

}

CURSOR_HPP
echo -e "\r"$(date +'%D %H:%M:%S') done generating src/cursor.hpp

cat << PROGRAM_HPP > src/program.hpp
#pragma once

#include "syntax.h"

namespace stanly{
struct program;
void append_node(program&, node&&);
void append_basic_block(program&, basic_block&&);
}
PROGRAM_HPP
echo -e "\r"$(date +'%D %H:%M:%S') done generating src/program.hpp


cat << PARSE_SYMBOLS_HPP > src/parse-symbols.hpp
#pragma once

#include "program.hpp"
#include <utility>
#include <variant>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly {

enum class symbol { $(jq -r '.type' <<< $symbols | $lookup_symbols | awk '{ print "sym_" $0 ","; }') };
enum class field { $(jq -r ".[].fields | keys? | .[]" < $nodes_json | $lookup_symbols fields | awk '{ print "fld_" $0 ","; }') };

template<symbol sym>
struct symbol_tag{};



$( while IFS="^" read -r name optional_fields required_fields children all_fields; do
        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/parse-symbols.hpp" > /dev/tty
cat << EOF
    void parse(program& p, std::variant<field, symbol> child, std::string_view text, symbol_tag<$name>){
                $([[ $children ]] && cat << SWITCH_CHILDREN
                if(symbol* s = std::get_if<symbol>(child)){
                    switch(*s){\
                        $( while read f; do \
                        [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                        echo "case sym_$f: break;" || ( 
                            for child in $(jq -r ".[] | select(.type == \"$f\").subtypes[].type" < $nodes_json); do
                                [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                                echo "case sym_$child: break;";
                            done);
                        done <<< ${children//,/$'\n'})\
                        default: throw "unreachable";\
                    }\
                }
SWITCH_CHILDREN
)
                $( [[ $all_fields ]] && cat << SWITCH_FIELDS
                if(field* f = std::get_if<field>(child)){
                    switch(*f){
                        $( while read f; do echo "case fld_$f: field_$f = h; break;"; done <<< ${all_fields//,/$'\n'})
                        default: throw "unreachable";
                    }
                    
                }
SWITCH_FIELDS
)
    }
    void parse_$name(
        program& p\
        $( [[ $children ]] && while read f; do echo ", std::optional<std::string_view> child_$f "; done <<< ${children//,/$'\n'})\
        $( [[ $optional_fields ]] && while read f; do echo ", std::optional<std::string_view> fld_$f "; done <<< ${optional_fields//,/$'\n'})\
        $( [[ $required_fields ]] && while read f; do echo ", std::string_view fld_$f "; done <<< ${required_fields//,/$'\n'}));
EOF
    done <<< "$norca_vars")
}
PARSE_SYMBOLS_HPP
n=0
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/parse-symbols.hpp"

cat << PARSER_HPP > src/parser.hpp
#pragma once

#include "cursor.hpp"
#include "program.hpp"

namespace stanly{
    void parser_trampoline(cursor&, program&);
}

PARSER_HPP
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/parser.hpp"


cat << PARSER_CPP > src/parser.cpp
#include "cursor.hpp"
#include "parse-symbols.hpp"
#include "parser.hpp"
#include "syntax.h"
#include <utility>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly {


template<class F>
requires std::invocable<F, field> && std::invocable<F, symbol>
void parse_descendants(cursor& c, program& p, F&& f){
    if(goto_child(c)){
        do{
            parser_trampoline(c, p);
            auto field = current_field(c);
            auto text = current_text(c);
            if (field) { 
                f(*field, text); 
            } else { 
                f(current_symbol(c), text); 
            }
        }
        while(goto_sibling(c));
        goto_parent(c);
    }
}

struct field_ref { 
    field field;
    std::string_view location;
}

struct symbol_ref {
    symbol symbol;
    std::string_view location;
}

template<std::invocable<F, const std::vector<field_ref>&, const std::vector<symbol_ref>&> F>
void parse_descendants(cursor& c, program p&, F&& f){
    std::vector<field_ref> field_refs = {};
    std::vector<symbol_ref> symbol_refs = {};
    parse_descendants(c, p, [&]<class T>(T x, std::string_view s){
        if constexpr(std::same_as<T, field>){
            field_refs.emplace_back(x, s);
        } else {
            static_assert(std::same_as<T, symbol>);
            symbol_refs.emplace_back(x, s);
        }
    });
    f(field_refs, symbol_refs);
}

void parser_trampoline(cursor& c, program& p) {
    using enum symbol;
    using enum field;
    switch(current_symbol(c)){
$( while IFS="^" read -r name optional_fields required_fields children all_fields; do
        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/parser.cpp" > /dev/tty
cat << EOF
        case $name: {
            $( [[ $children ]] && while read f; do echo "std::optional<std::string_view> child_$f = std::nullopt; "; done <<< ${children//,/$'\n'})
            $( [[ $optional_fields ]] && while read f; do echo "std::optional<std::string_view> field_$f = std::nullopt; "; done <<< ${optional_fields//,/$'\n'})
            $( [[ $required_fields ]] && while read f; do echo "std::string_view field_$f; "; done <<< ${required_fields//,/$'\n'})
            $( cat << PARSE_DESCENDANTS
            parse_descendants(c,  p \
                $([[ $children ]] && cat << SWITCH_CHILDREN 
                , [&](symbol s, std::string_view h){\
                    switch(s){\
                        $( while read f; do \
                        [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                        echo "case sym_$f: child_$f = h; break;" || ( 
                            for child in $(jq -r ".[] | select(.type == \"$f\").subtypes[].type" < $nodes_json); do
                                [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                                echo "case sym_$child: child_$f = h; break;";
                            done);
                        done <<< ${children//,/$'\n'})\
                        default: throw "unreachable";\
                    }\
                }
SWITCH_CHILDREN
)
                $( [[ $all_fields ]] && cat << SWITCH_FIELDS
                , [&](field f, std::string_view h){
                    switch(f){
                        $( while read f; do echo "case fld_$f: field_$f = h; break;"; done <<< ${all_fields//,/$'\n'})
                        default: throw "unreachable";
                    }
                    
                }
SWITCH_FIELDS
)
                
            );
            
PARSE_DESCENDANTS
)
            
            parse_${name} (\
                p\
                $( [[ $children ]] && while read f; do echo ", child_$f"; done <<< ${children//,/$'\n'})\
                $( [[ $optional_fields ]] && while read f; do echo ", field_$f"; done <<< ${optional_fields//,/$'\n'})\
                $( [[ $required_fields ]] && while read f; do echo ", field_$f"; done <<< ${required_fields//,/$'\n'}));
            return;
        }
EOF

done <<< "$norca_vars")
    };
    throw "unreachable";
}

}

PARSER_CPP

echo -ne "\r"$(date +'%D %H:%M:%S') done generating src/parser.cpp"\n"

function lint {
    clang-format -i $1
    /home/kai/projects/install/bin/clang++ -std=c++20 -stdlib=libc++ -fexperimental-library -fsyntax-only $1 -Wall -Werror -Wno-unused-variable
}
lint src/cursor.hpp
lint src/parse-symbols.hpp
lint src/parser.hpp
lint src/parser.cpp

echo $(date +'%D %H:%M:%S') done linting
