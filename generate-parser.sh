[[ $1 ]] && nodes_json="$1" || nodes_json="build-default/tree-sitter-python/src/node-types.json"
[[ $2 ]] && lookup_symbols="$2" || lookup_symbols="build-default/src/lookup-symbols"

symbols=$(jq -r -c '.[] | select(.named) | select(.subtypes == null)' < $nodes_json)
name=$(jq -r '"sym_" + .type' <<< $symbols) 
optional_fields=$(jq -r -c '.fields // {} | map_values(select(.required == false)) | keys' <<< $symbols)
required_fields=$(jq -r -c '.fields // {} | map_values(select(.required)) | keys' <<< $symbols)
children=$(jq -r -c '.children.types // [] | [.[].type]' <<< $symbols)
#children=$(jq '. as $json | .[] | [select(.named)] | .[] | select(.subtypes == null) | .children.types // [] | [.[].type as $t | ($json[] | select(.type == $t).subtypes) as $st | if $st==null then $t else $st[].type end]' < $nodes_json)
all_fields=$(jq -r -c '.fields // {} | keys' <<< $symbols)
n_symbols=$(wc -l <<< $symbols)
norca_vars=$(paste -d "^" <(echo "$name") <(echo "$optional_fields") <(echo "$required_fields") <(echo "$children") | awk '{ gsub("\[\]", ""); print  }' | tr -d "[]\"")
n=0

cat << CURSOR_HPP > src/cursor.hpp
#pragma once

#include "syntax.h"
#include "handle.h"
#include <utility>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

enum class symbol;
enum class field;
struct cursor;

handle current_handle(cursor&);
symbol current_symbol(cursor&);
std::optional<field> current_field(cursor&);

std::optional<handle> goto_child(cursor&);
std::optional<handle> goto_sibling(cursor&);
void goto_parent(cursor&);

std::vector<syntax::basic_block>& get_basic_blocks(cursor&);

enum class symbol { $(jq -r '.type' <<< $symbols | $lookup_symbols | awk '{ print "sym_" $0 ","; }') };
enum class field { $(jq -r ".[].fields | keys? | .[]" < $nodes_json | $lookup_symbols fields | awk '{ print "fld_" $0 ","; }') };


}

CURSOR_HPP
echo -e "\r"$(date +'%D %H:%M:%S') done generating src/cursor.hpp

cat << PARSE_SYMBOLS_HPP > src/parse-symbols.hpp
#pragma once

#include "handle.h"
#include <utility>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

struct cursor;

$( while IFS="^" read -r name optional_fields required_fields children all_fields; do
        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/parse-symbols.hpp" > /dev/tty
cat << EOF
    void parse_$name(
        cursor& c\
        $( [[ $children ]] && while read f; do echo ", std::optional<handle> child_$f "; done <<< ${children//,/$'\n'})\
        $( [[ $optional_fields ]] && while read f; do echo ", std::optional<handle> fld_$f "; done <<< ${optional_fields//,/$'\n'})\
        $( [[ $required_fields ]] && while read f; do echo ", handle fld_$f "; done <<< ${required_fields//,/$'\n'}));
EOF
    done <<< "$norca_vars")
}
PARSE_SYMBOLS_HPP
n=0
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/parse-symbols.hpp"

cat << PARSER_HPP > src/parser.hpp
#pragma once

namespace stanly::parser{
    struct cursor;
    void parser_trampoline(cursor&);
}

PARSER_HPP
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/parser.hpp"


cat << PARSER_CPP > src/parser.cpp
#include "cursor.hpp"
#include "parse-symbols.hpp"
#include "parser.hpp"
#include <utility>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

void parse_descendants(cursor& c, auto&& f_child, auto&& f_field){
    if(goto_child(c)){
        do{
            parser_trampoline(c);
            auto field = current_field(c);
            auto handle = current_handle(c);
            if (field) { 
                f_field(*field, handle); 
            } else { 
                f_child(current_symbol(c), handle); 
            }
        }
        while(goto_sibling(c));
        goto_parent(c);
    }
}

void parser_trampoline(cursor& c) {
    using enum symbol;
    using enum field;
    switch(current_symbol(c)){
$( while IFS="^" read -r name optional_fields required_fields children all_fields; do
        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/parser.cpp" > /dev/tty
cat << EOF
        case $name: {
            $( [[ $children ]] && while read f; do echo "std::optional<handle> child_$f = std::nullopt; "; done <<< ${children//,/$'\n'})
            $( [[ $optional_fields ]] && while read f; do echo "std::optional<handle> field_$f = std::nullopt; "; done <<< ${optional_fields//,/$'\n'})
            $( [[ $required_fields ]] && while read f; do echo "handle field_$f; "; done <<< ${required_fields//,/$'\n'})
            parse_descendants(\
                c, \
                [&](symbol s, handle h){\
                    switch(s){\
                        $( [[ $children ]] && while read f; do \
                        [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                        echo "case sym_$f: child_$f = h; break;" || ( 
                            for child in $(jq -r ".[] | select(.type == \"$f\").subtypes[].type" < $nodes_json); do
                                [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                                echo "case sym_$child: child_$f = h; break;";
                            done);
                        done <<< ${children//,/$'\n'})\
                        default: throw "unreachable";\
                    }\
                },
                [&](field f, handle h){
                    switch(f){
                        $( [[ $all_fields ]] && while read f; do echo "case fld_$f: field_$f = h; break;"; done <<< ${all_fields//,/$'\n'})
                        default: throw "unreachable";
                    }
                    
                }
            );
            parse_${name} (\
                c\
                $( [[ $children ]] && while read f; do echo ", child_$f"; done <<< ${children//,/$'\n'})\
                $( [[ $optional_fields ]] && while read f; do echo ", field_$f"; done <<< ${optional_fields//,/$'\n'})\
                $( [[ $required_fields ]] && while read f; do echo ", field_$f"; done <<< ${required_fields//,/$'\n'}));
            return;
        }
EOF

done <<< "$norca_vars")
    };
    throw "unreachable";
}

}

PARSER_CPP

echo -ne "\r"$(date +'%D %H:%M:%S') done generating src/parser.cpp"\n"

function lint {
    sed -i '/{}/d' $1
    clang-format -i $1
    sed -i '/{}/d' $1
    /home/kai/projects/install/bin/clang++ -std=c++20 -stdlib=libc++ -fexperimental-library -fsyntax-only $1 -Wall -Werror -Wno-unused-variable
}
lint src/cursor.hpp
lint src/parse-symbols.hpp
lint src/parser.hpp
lint src/parser.cpp

echo $(date +'%D %H:%M:%S') done linting
