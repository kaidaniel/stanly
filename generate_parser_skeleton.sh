[[ $1 ]] && nodes_json="$1" || nodes_json="build-default/tree-sitter-python/src/node-types.json"
[[ $2 ]] && lookup_symbols="$2" || lookup_symbols="build-default/src/lookup-symbols"

fields=$(jq -r ".[].fields | keys? | .[]" < $nodes_json | $lookup_symbols fields | awk '{ print "fld_" $0 ","; }')
n_fields=$(wc -l <<< $fields)
symbols=$(jq -r '.[] | select("named") | select(.subtypes == null).type' < $nodes_json | $lookup_symbols | awk '{ print "sym_" $0 ","; }')
n_symbols=$(jq '[.[] | select("named") | select(.subtypes == null)] | length' $nodes_json)
n=0

cat << CURSOR_HPP > src/cursor.hpp
#pragma once

#include "syntax.h"
#include "handle.h"
#include <utility>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

enum class symbol;
enum class field;
struct cursor;

handle current_handle(cursor&);
symbol current_symbol(cursor&);
std::optional<field> current_field(cursor&);

std::optional<handle> goto_child(cursor&);
std::optional<handle> goto_sibling(cursor&);
void goto_parent(cursor&);

std::vector<syntax::basic_block>& get_basic_blocks(cursor&);

enum class symbol { ${symbols} };
enum class field { ${fields} };


}

CURSOR_HPP
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/cursor.hpp"


cat << PARSE_SYMBOLS_HPP > src/parse_symbols.hpp
#pragma once

#include "syntax.h"
#include "handle.h"
#include <utility>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

struct cursor;

$(  for symbol in $(jq -r -c '.[] | select(.named) | select(.subtypes == null)' < $nodes_json); do
        name="sym_"$( <<< $symbol jq -r '.type') 
        optional_fields=$(jq -r -c '.fields | map_values(select(.required == false))? | keys? | .[]' <<< $symbol)
        required_fields=$(jq -r -c '.fields | map_values(select(.required))? | keys? | .[]' <<< $symbol)
        children=$(jq -r -c 'select(.children != null).children.types[].type' <<< $symbol)
        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/parse_symbols.hpp" > /dev/tty
cat << EOF
    void parse_$name(
        cursor& c\
        $( [[ $children ]] && while read f; do echo ", std::optional<handle> child_$f "; done <<< "$children")\
        $( [[ $optional_fields ]] && while read f; do echo ", std::optional<handle> fld_$f "; done <<< "$optional_fields")\
        $( [[ $required_fields ]] && while read f; do echo ", handle fld_$f "; done <<< "$required_fields"));
EOF
    done)
}
PARSE_SYMBOLS_HPP
n=0
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/parse_symbols.hpp"

cat << PARSER_HPP > src/parser.hpp
#pragma once

namespace stanly::parser{
    struct cursor;
    void parser_trampoline(cursor&);
}

PARSER_HPP
echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/parser.hpp"


cat << PARSER_CPP > src/parser.cpp
#include "cursor.hpp"
#include "parse_symbols.hpp"
#include "parser.hpp"
#include <utility>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

void parse_descendants(cursor& c, auto&& f_child, auto&& f_field){
    if(goto_child(c)){
        do{
            parser_trampoline(c);
            auto field = current_field(c);
            auto handle = current_handle(c);
            if (field) { 
                f_field(*field, handle); 
            } else { 
                f_child(current_symbol(c), handle); 
            }
        }
        while(goto_sibling(c));
        goto_parent(c);
    }
}

void parser_trampoline(cursor& c) {
    using enum symbol;
    using enum field;
    switch(current_symbol(c)){
$( for symbol in $(jq -r -c '.[] | select(.named) | select(.subtypes == null)' < $nodes_json); do
        name="sym_"$( <<< $symbol jq -r '.type') 
        optional_fields=$(jq -r -c '.fields | map_values(select(.required == false))? | keys? | .[]' <<< $symbol)
        required_fields=$(jq -r -c '.fields | map_values(select(.required))? | keys? | .[]' <<< $symbol)
        children=$(jq -r -c 'select(.children != null).children.types[].type' <<< $symbol)
        all_fields=$(jq -r -c '.fields | keys? | .[]' <<< $symbol)

        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/parser.cpp" > /dev/tty
cat << EOF
        case $name: {
            $( [[ $children ]] && while read f; do echo "std::optional<handle> child_$f = std::nullopt; "; done <<< "$children")
            $( [[ $optional_fields ]] && while read f; do echo "std::optional<handle> field_$f = std::nullopt; "; done <<< "$optional_fields")
            $( [[ $required_fields ]] && while read f; do echo "handle field_$f; "; done <<< "$required_fields")
            parse_descendants(\
                c, \
                [&](symbol s, handle h){\
                    switch(s){\
                        $( [[ $children ]] && while read f; do \
                        [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                        echo "case sym_$f: child_$f = h; break;" || ( 
                            for child in $(jq -r ".[] | select(.type == \"$f\").subtypes[].type" < $nodes_json); do
                                [[ "$(jq -r -c ".[] | select(.type == \"$f\") | select(.subtypes == null)" < $nodes_json)" ]] && \
                                echo "case sym_$child: child_$f = h; break;";
                            done);
                        done <<< $children)\
                        default: throw "unreachable";\
                    }\
                },
                [&](field f, handle h){
                    switch(f){
                        $( [[ $all_fields ]] && while read f; do echo "case fld_$f: field_$f = h; break;"; done <<< "$all_fields")
                        default: throw "unreachable";
                    }
                    
                }
            );
            parse_${name} (\
                c\
                $( [[ $children ]] && while read f; do echo ", child_$f"; done <<< "$children")\
                $( [[ $optional_fields ]] && while read f; do echo ", field_$f"; done <<< "$optional_fields")\
                $( [[ $required_fields ]] && while read f; do echo ", field_$f"; done <<< "$required_fields"));
            return;
        }
EOF

done)
    };
    throw "unreachable";
}

}

PARSER_CPP

echo $(date +'%D %H:%M:%S') done generating "src/parser.cpp"

function lint {
    sed -i '/{}/d' $1
    clang-format -i $1
    sed -i '/{}/d' $1
    /home/kai/projects/install/bin/clang++ -std=c++20 -stdlib=libc++ -fexperimental-library -fsyntax-only $1 -Wall -Werror -Wno-unused-variable
}
lint src/cursor.hpp
lint src/parse_symbols.hpp
lint src/parser.hpp
lint src/parser.cpp

echo $(date +'%D %H:%M:%S') done linting