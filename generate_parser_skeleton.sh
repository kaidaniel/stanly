[[ $1 ]] && nodes_json="$1" || nodes_json="build-default/tree-sitter-python/src/node-types.json"
[[ $2 ]] && lookup_symbols="$2" || lookup_symbols="build-default/src/lookup-symbols"

cat << HEADER > src/parser.hpp
#pragma once
#include <utility>
#include <string_view>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

    enum class fields;
    struct parser;

    std::optional<std::string_view> parse_field(parser&, enum fields);
    std::optional<std::string_view> parse_children(parser&);

    enum class fields {
        $(jq -r ".[].fields | keys? | .[]" < $nodes_json | $lookup_symbols fields)
    };

    $( for name in $(jq -r -c '.[] | select(.named).type' < $nodes_json); do
        echo "void parse_$name(parser&);"
    done)
}
HEADER

echo $(date +'%D %H:%M:%S') done generating "src/parser.hpp"

n_symbols=$(jq '[.[] | select("named")] | length' $nodes_json)
n=0

cat << SKELETON > src/.parser_skeleton.cpp
#include "syntax.h"
#include <utility>
#include <string_view>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

struct ast_node_args {
    syntax::ast_node node;
    std::vector<std::string_view> args;
};

$(  for symbol in $(jq -r -c '.[] | select(.named)' < $nodes_json); do
        name="sym_"$( <<< $symbol jq -r '.type') 
        field_names=$(<<< $symbol jq -r -c '.fields | keys? | .[]')
        n=$((n + 1))
        echo -ne "\r$n/$n_symbols generating src/.parser_skeleton.cpp" > /dev/tty
cat << EOF
        ast_node_args parse_$name(
            std::optional<std::string_view> children
            $( [[ $field_names ]] && while read f; do echo ", std::optional<std::string_view> sym_$f "; done <<< "$field_names")
            ){ 
/* 
$( jq '{
    fields: (.fields // {}) | map_values([.types[]?.type]), 
    children: (if .children then {multiple: .children.multiple, required: .children.required, types: [.children.types[]?.type]} else null end), 
    subtypes: [.subtypes[]?.type]
    } | map_values(select(length > 0))' <<< $symbol | tr -d '",{}[]' | sed '/^[[:space:]]*$/d'
) 
*/
        }
EOF
    done)
}
SKELETON

echo -e "\r"$(date +'%D %H:%M:%S') done generating "src/.parser_skeleton.cpp"


cat << TRAMPOLINE > src/parser_trampoline.cpp
#include "parser.hpp"
#include <utility>
#include <string_view>

// generated by "$0 $nodes_json $lookup_symbol"

namespace stanly::parser {

enum class symbols;
enum class fields;
struct parser;

enum class symbols {
    $(jq -r '.[] | select(.named).type' < $nodes_json | $lookup_symbols)
};

void parser_trampoline(parser& p) {}

}

TRAMPOLINE

echo $(date +'%D %H:%M:%S') done generating "src/parser_trampoline.cpp"

function lint {
    sed -i '/{}/d' $1
    clang-format -i $1
    sed -i '/{}/d' $1
    /home/kai/projects/install/bin/clang++ -stdlib=libc++ -fexperimental-library -fsyntax-only $1 -Wall -Werror -Wno-unused-variable
}
lint src/parser.hpp
lint src/.parser_skeleton.cpp
lint src/parser_trampoline.cpp

echo $(date +'%D %H:%M:%S') done linting